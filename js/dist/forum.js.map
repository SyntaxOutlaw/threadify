{"version":3,"file":"forum.js","mappings":"MACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3ER,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFf,EAAyBM,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,M,0TCLvD,MAAM,EAA+BC,OAAOC,KAAKC,OAAO,a,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,iBCAlD,EAA+BF,OAAOC,KAAKC,OAAO,+B,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,mC,aCqFjD,SAASC,EAAoBC,GAElC,IAAKA,EAEH,OADAC,QAAQC,IAAI,oEACL,EAIT,IAAMC,EACJC,IAAIC,OAAwC,mBAAxBD,IAAIC,MAAMC,UAC1BF,IAAIC,MAAMC,UAAU,iBACpB,KACAC,EAAOJ,GAAW,UAMlBK,GAHJJ,IAAIC,OAAwC,mBAAxBD,IAAIC,MAAMC,UAC1BF,IAAIC,MAAMC,UAAU,gBACpB,OACgC,YAetC,GAbAL,QAAQC,IACN,mCACA,kBACyB,mBAAlBF,EAAWS,GAAoBT,EAAWS,KAAOT,EAAWS,GACnE,sBACAN,EACA,mBACAI,EACA,mBACAC,GAIW,YAATD,EAEF,OADAN,QAAQC,IAAI,0FACL,EAIT,GAAa,QAATK,EAAgB,CAElB,IAAIG,EAAO,GAGX,GAA+B,mBAApBV,EAAWU,KAAqB,CACzC,IAAMC,EAAMX,EAAWU,OACnBE,MAAMC,QAAQF,KAChBD,EAAOC,EAEX,MAAWX,EAAWc,MAAQd,EAAWc,KAAKC,eAAiBf,EAAWc,KAAKC,cAAcL,OAG3FA,GADYV,EAAWc,KAAKC,cAAcL,KAAKI,MAAQ,IAEpDE,IAAI,SAAAC,GACH,OAAKA,GAAWA,EAAOR,IAChBL,IAAIc,OAASd,IAAIc,MAAMC,QAAUf,IAAIc,MAAMC,QAAQ,OAAQF,EAAOR,IADvC,IAEpC,GACCW,OAAO,SAAAC,GAAG,OAAIA,CAAG,IAGtB,IAAKX,IAASA,EAAKY,OAEjB,OADArB,QAAQC,IAAI,8FACL,EAIT,IAAMqB,EAAWb,EAAKM,IAAI,SAAAQ,GACxB,OAAKA,EACiB,mBAAXA,EAAEC,KAA4BD,EAAEC,OACvCD,EAAEC,KAAaD,EAAEC,KACjBD,EAAEV,MAAQU,EAAEV,KAAKY,YAAcF,EAAEV,KAAKY,WAAWD,KAAaD,EAAEV,KAAKY,WAAWD,KAC7E,YAJQ,QAKjB,GAGME,EAAmBJ,EAASK,SAASpB,GAW3C,OATAP,QAAQC,IACN,8DACAM,EACA,oBACAe,EACA,uBACAI,GAGKA,CACT,CAIA,OADA1B,QAAQC,IAAI,sDAAuDK,EAAM,yBAClE,CACT,CAUO,SAASsB,EAAsBC,GACpC,OAAKA,QAAqC,IAAtBA,EAAKC,aAIlB,CACLC,MAAOF,EAAKC,aACZE,WAAYH,EAAKI,YACjBC,OAAQL,EAAKM,QACbC,WAAYP,EAAKQ,YACjBC,gBAAiBT,EAAKU,iBACtBC,WAAYX,EAAKY,aATV,IAWX,CClLA,IAAIC,GAAgB,EAChBC,EAAgB,KAChBC,EAAsB,KACtBC,EAAgB,EAEpB,SAASC,EAAepE,EAAGqE,GACzB,OAAY,MAALrE,GAAkB,MAALqE,GAAaC,OAAOtE,KAAOsE,OAAOD,EACxD,CAmCA,SAASE,EAAyBC,GAC3BA,IACLN,EAAsBM,EACtBR,GAAgB,EAChBC,EAAgB,KDhDX,SAA+BO,GAIpC,OAHAlD,QAAQC,IAAI,8CAA8CiD,GAGnD/C,IAAIgD,QAAQ,CACjBC,OAAQ,MACRC,IAAKlD,IAAIC,MAAMC,UAAU,UAAY,gBAAkB6C,EAAe,aACrEI,KAAK,SAAAC,GACNvD,QAAQC,IAAI,sBAAsBsD,EAAS1C,KAAKQ,OAAM,mBAGlDkC,EAASC,WACXxD,QAAQC,IAAI,0BAA0BsD,EAASC,SAASnC,OAAM,UAC9DkC,EAASC,SACNrC,OAAO,SAAAsC,GAAI,OAAIA,GAAQA,EAAKC,MAAQD,EAAKjD,EAAE,GAC3CmD,QAAQ,SAAAF,GACPtD,IAAIc,MAAM2C,WAAWH,EACvB,IAIJ,IAAMI,EAAeN,EAAS1C,KAAKE,IAAI,SAAA+C,GACrC,IAAMC,EAASD,EAAWrC,WAAWsC,OACjClC,EAAO1B,IAAIc,MAAMC,QAAQ,QAAS6C,GAYtC,OAVIlC,IACFA,EAAKC,aAAegC,EAAWrC,WAAWM,MAC1CF,EAAKI,YAAc6B,EAAWrC,WAAWO,WACzCH,EAAKM,QAAU2B,EAAWrC,WAAWS,OACrCL,EAAKQ,YAAcyB,EAAWrC,WAAWW,WACzCP,EAAKU,iBAAmBuB,EAAWrC,WAAWa,gBAC9CT,EAAKY,YAAcqB,EAAWrC,WAAWe,WACzCX,EAAKmC,cAAgBF,EAAWrC,WAAWwC,cAGtCpC,CACT,GAAGV,OAAO,SAAAU,GAAI,OAAa,OAATA,CAAa,GAK/B,OADA7B,QAAQC,IAAI,yBAAyB4D,EAAaxC,OAAM,+BACjDwC,CACT,GAAE,MAAO,SAAAK,GAIP,OAHAlE,QAAQkE,MAAM,iDAAkDA,GAGzD,EACT,EACF,CCCEC,CAAsBjB,GACnBI,KAAK,SAAAc,GACCtB,EAAeF,EAAqBM,KAEzCR,GAAgB,EAChBG,GAFAF,EAAgByB,GAAS,IAEKjD,OAAO,SAAAkD,GAAC,OAAIA,CAAC,GAAEhD,OAtCnD,SAAwC6B,EAAcoB,GACpD,GAAKA,GAAiBA,EAAajD,OAAnC,CACA,IAAMtB,EACJI,IAAAA,MAAUe,QAAQ,cAAe8B,OAAOE,KACxC/C,IAAAA,MAAUe,QAAQ,cAAeqD,OAAOrB,IAC1C,GAAKnD,EAAL,CAMA,IAAMc,EAAOyD,EAAavD,IAAI,SAAAsD,GAAC,MAAK,CAClCX,KAAM,QACNlD,GAAIwC,OAAuB,mBAATqB,EAAE7D,GAAoB6D,EAAE7D,KAAO6D,EAAE7D,IACpD,GACIT,EAAWc,KAAKC,gBAAef,EAAWc,KAAKC,cAAgB,CAAC,GACrEf,EAAWc,KAAKC,cAAcsD,MAAQ,CAAEvD,KAAAA,GACxCd,EAAWyE,UAAY,IAAIC,KAG3B,IAAMC,EAASvE,IAAAA,QAAYjB,IAAI,UAC3BwF,GAAUA,EAAO3E,aAAeA,IAClC2E,EAAOC,WAAa,WAClB,OAAO,CACT,EAdF,KALA,CAC8D,IAAAC,EAAtC,oBAAXC,QAA0BA,OAAOC,gBAC1C9E,QAAQ+E,KAAK,uCAAwC7B,EAAc,cAA6B,OAAd0B,EAAAzE,IAAAA,MAAUU,OAAV+D,EAAgBI,YAAcjG,OAAOkG,KAAK9E,IAAAA,MAAUU,KAAKmE,aAAe,GAG9J,CATiD,CAyBnD,CAaME,CAA+BhC,EAAcP,GAC7CwC,EAAEC,SACJ,GAAE,MACK,WACL1C,GAAgB,EAChBC,EAAgB,KAChBwC,EAAEC,QACJ,GACJ,CASO,SAASC,KACdC,EAAAA,EAAAA,QAAOC,IAAAA,UAA0B,OAAQ,SAASC,GAChD,OAAO,SAASzF,GAEd,GADAyF,EAASjG,KAAKkG,KAAM1F,GACf0F,KAAKf,QAAWe,KAAKf,OAAO3E,WAAjC,CACA,IAAM2F,EAAkBD,KAAKf,OAAO3E,WAC9BmD,EAAewC,EAAgBlF,KAChCsC,EAAeF,EAAqBM,KACvCN,EAAsBM,EACtBR,GAAgB,EAChBC,EAAgB,MAEd7C,EAAoB4F,IACtBzC,EAAyBC,EATwB,CAWrD,CACF,IAEAoC,EAAAA,EAAAA,QAAOK,IAAAA,UAAsB,SAAU,WACrC,IAAMjB,EAASe,KAAKf,OACpB,GAAKA,GAAWA,EAAO3E,WAAvB,CACA,IAAMmD,EAAewB,EAAO3E,WAAWS,KAClCsC,EAAeF,EAAqBM,KACvCN,EAAsBM,EACtBR,GAAgB,EAChBC,EAAgB,MAEd7C,EAAoB4E,EAAO3E,cAE7B2E,EAAOC,WAAa,WAClB,OAAO,CACT,EACKjC,GACHO,EAAyBC,GAbY,CAgB3C,IAEAoC,EAAAA,EAAAA,QAAOK,IAAAA,UAAsB,WAAY,WACvC,GAAK7F,EAAoB2F,KAAKf,OAAO3E,YAArC,CACA,IAAM2E,EAASe,KAAKf,OACdkB,EAAQlB,EAAO3E,YAAc2E,EAAO3E,WAAW8F,WAAa,IAAIxE,OAAS,EAC3EuE,IAAU/C,IACZA,EAAgB+C,EAChBlD,GAAgB,EAChBC,EAAgB,KAChBM,EAAyByB,EAAO3E,WAAWS,MAPW,CAS1D,EACF,CAOO,SAASsF,IACd,MAAO,CACLpD,cAAAA,EACAqD,mBAAoBpD,EACpBqD,kBAAmBrD,EAAgBA,EAActB,OAAS,EAC1DuB,oBAAAA,EAEJ,CAOO,SAASqD,IACdvD,GAAgB,EAChBC,EAAgB,KACZC,GAAqBK,EAAyBL,GAClDuC,EAAEC,QACJ,CAOO,SAASc,IACd,OAAOxD,KAAmBC,CAC5B,CChLA,MAAM,EAA+BhD,OAAOC,KAAKC,OAAO,yB,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,kC,aC0DjD,SAASsG,EAA2BC,GACzC,IAAKA,GAA8B,iBAAZA,EACrB,OAAO,KAKT,IAAMC,EAAmBD,EAAQE,MAAM,mBAEvC,GAAID,GAAoBA,EAAiB,GAAI,CAC3C,IAAME,EAAWC,SAASH,EAAiB,GAAI,IAG/C,IAAKI,MAAMF,IAAaA,EAAW,EACjC,OAAOA,CAEX,CAEA,OAAO,IACT,CCPO,SAASG,EAAkBC,GAChC,IAAMC,EAAS,GAOf,SAASC,EAAmBhF,EAAME,GAChC,QADqC,IAALA,IAAAA,EAAQ,GACnCF,EAAL,CAEA+E,EAAOE,KAAKjF,GAGZ,IAAMkF,EAAWlF,EAAKmF,iBAAmB,GACzCD,EAASE,KAAK,SAACvI,EAAGqE,GAGhB,OAFcrE,EAAEwI,UAAYxI,EAAEwI,YAAYC,UAAY,IACxCpE,EAAEmE,UAAYnE,EAAEmE,YAAYC,UAAY,EAExD,GAGAJ,EAASpD,QAAQ,SAAAyD,GACfP,EAAmBO,EAAOrF,EAAQ,EACpC,EAfiB,CAgBnB,CAcA,OAXA4E,EAAUM,KAAK,SAACvI,EAAGqE,GAGjB,OAFcrE,EAAEwI,UAAYxI,EAAEwI,YAAYC,UAAY,IACxCpE,EAAEmE,UAAYnE,EAAEmE,YAAYC,UAAY,EAExD,GAGAR,EAAUhD,QAAQ,SAAA0D,GAChBR,EAAmBQ,EACrB,GAEOT,CACT,CAWO,SAASU,EAAoBlD,GAClC,IAAMmD,EAnGD,SAAyBnD,GAC9B,IAAMoD,EAAO,GACPC,EAAU,IAAIC,IACdC,EAAc,IAAID,IAClBlH,EAAK,SAAC6D,GAAC,OAAMA,GAAqB,mBAATA,EAAE7D,GAAoBwC,OAAOqB,EAAE7D,MAAQwC,OAAOqB,EAAE,EA6B/E,OA1BAD,EAAMT,QAAQ,SAAA9B,GACZ,GAAKA,EAAL,CACA,IAAMkC,EAASvD,EAAGqB,GAClB4F,EAAQG,IAAI7D,EAAQlC,GACpB8F,EAAYC,IAAI7D,EAAQ,GAHP,CAInB,GAGAK,EAAMT,QAAQ,SAAA9B,GAAQ,IAAAgG,EACpB,GAAKhG,EAAL,CACA,IAAM0E,EAAsC,OAA9BsB,EAAGhG,EAAKxB,UAAU,cAAYwH,EAAIhG,EAAKmC,cAC/C8D,EAAwB,MAAZvB,EAAmBvD,OAAOuD,GAAY,KAEpDuB,GAAaL,EAAQM,IAAID,GAC3BH,EAAYzI,IAAI4I,GAAWhB,KAAKjF,GAEhC2F,EAAKV,KAAKjF,EAPK,CASnB,GAGAuC,EAAMT,QAAQ,SAAA9B,GACPA,IACLA,EAAKmF,gBAAkBW,EAAYzI,IAAIsB,EAAGqB,KAAU,GACtD,GAEO2F,CACT,CAiEqBQ,CAAgB5D,GACnC,OAAOsC,EAAkBa,EAC3B,CC9GA,IAAMU,EAAmB,IAAIP,IAGvBQ,EAAmB,GAYlB,SAASC,EAAqBtG,EAAMuG,GACzC,IAAMrE,EAASlC,EAAKrB,KAGpB,GAAIyH,EAAiBF,IAAIhE,GACvB,OAAOkE,EAAiB/I,IAAI6E,GAI9B,IAAMwC,EAAW1E,EAAKxB,UAAU,aAChC,IAAKkG,EAEH,OADA0B,EAAiBL,IAAI7D,EAAQ,GACtB,EAKT,IADmBqE,EAASC,KAAK,SAAAhE,GAAC,OAAIA,GAAKA,EAAE7D,MAAQ+F,CAAQ,GAI3D,OADA0B,EAAiBL,IAAI7D,EAAQ,GACtB,EAKT,IACMhC,EAAQuG,EAAwBzG,EAAMuG,EAD5B,IAAIG,KAKpB,OADAN,EAAiBL,IAAI7D,EAAQhC,GACtBA,CACT,CASA,SAASuG,EAAwBzG,EAAMuG,EAAUI,GAC/C,IAAMzE,EAASlC,EAAKrB,KAGpB,GAAIgI,EAAQT,IAAIhE,GAEd,OADA/D,QAAQ+E,KAAK,uCAAuChB,GAC7C,EAIT,GAAIkE,EAAiBF,IAAIhE,GACvB,OAAOkE,EAAiB/I,IAAI6E,GAI9B,IAAMwC,EAAW1E,EAAKxB,UAAU,aAChC,IAAKkG,EACH,OAAO,EAIT,IAAMkC,EAAaL,EAASC,KAAK,SAAAhE,GAAC,OAAIA,GAAKA,EAAE7D,MAAQ+F,CAAQ,GAC7D,IAAKkC,EACH,OAAO,EAITD,EAAQE,IAAI3E,GAGZ,IACMhC,EADcuG,EAAwBG,EAAYL,EAAUI,GACtC,EAM5B,OAHAA,EAAO,OAAQzE,GAGR4E,KAAKC,IAAI7G,EAAOmG,EACzB,CAQO,SAASW,IACdZ,EAAiBa,OACnB,CChBO,SAASC,IACd,MAAO,CACLC,QAAS,MACTC,KAAM,YACNC,OAAQ,eACRC,UAAU,EACVC,WAAY,CACVC,WAAY,SACZxH,KAAM,SACNyH,cAAe,UAEjBC,SAAU,CACR,8BACA,sCACA,iCACA,uCAGN,CAvFApJ,IAAIqJ,aAAad,IAAI,yBAA0B,WAC7C,IAEErD,KCVFC,EAAAA,EAAAA,QAAOmE,IAAAA,UAAgB,UAAW,SAASC,GACzC,IAAM7H,EAAO4D,KAAKkE,MAAM9H,KAGxB,IAAKA,EAEH,OADA7B,QAAQ+E,KAAK,+CACN2E,EAIT,IAAM3J,EAAwC,mBAApB8B,EAAK9B,WAA4B8B,EAAK9B,aAAe,KAC/E,OAAKA,GAAeD,EAAoBC,ICqBrC,SAA6B8B,GAClC,IAAME,EA9BD,SAAwBF,GAC7B,IAAKA,EACH,OAAO,EAIT,IAAM+H,EAAWhI,EAAsBC,GACvC,OAAI+H,EACKjB,KAAKC,IAAIgB,EAAS7H,MAlBH,IAsBPF,EAAKxB,UAAU,aAIvB,EAIF,CACT,CASgBwJ,CAAehI,GACvB6H,EAAU,GAEZ3H,EAAQ,GACV2H,EAAQ5C,KAAK,iBACb4C,EAAQ5C,KAAK,gBAAgB/E,GAGzBA,GAAS,GACX2H,EAAQ5C,KAAK,eAEX/E,GAAS,GACX2H,EAAQ5C,KAAK,qBAGf4C,EAAQ5C,KAAK,eAIf,IAAM8C,EAAWhI,EAAsBC,GAcvC,OAbI+H,IACEA,EAAS1H,QACXwH,EAAQ5C,KAAK,yBAEX8C,EAASxH,WAAa,IACxBsH,EAAQ5C,KAAK,gBACb4C,EAAQ5C,KAAK,eAAe6B,KAAKC,IAAIgB,EAASxH,WAAY,MAExDwH,EAAStH,gBAAkB,GAC7BoH,EAAQ5C,KAAK,oBAIV4C,CACT,CDnD0BI,CAAoBjI,GAE5B8B,QAAQ,SAAAoG,GACpBL,EAAQ5C,KAAKiD,EACf,GAEOL,GAVEA,CAWX,IJjBApE,EAAAA,EAAAA,QAAO0E,IAAAA,UAAyB,OAAQ,SAASnJ,GAE/C,IAAM0F,EAAWJ,EAA2BtF,EAAKuF,SAQjD,OANIG,IAEF1F,EAAKoJ,UAAY1D,EACjBvG,QAAQC,IAAI,sCAAuCsG,IAG9C1F,CACT,GGHEb,QAAQC,IAAI,yCAGZ4E,OAAOC,eAAiB,CACtBoF,SAAUpE,EACVqE,OAAQlE,EACRkD,SAAUjD,EACVkE,KAAM,WACJpK,QAAQC,IAAI,uWAQd,EACAoK,SAAU,WACR,IAAMtK,EAAaI,IAAImK,QAAQpL,IAAI,cAC7BqL,EAAQzE,IACR0E,EAAOzK,EAAaI,IAAIc,MAAMC,QAAQ,cAAe8B,OAAOjD,EAAWS,QAAUL,IAAIc,MAAMC,QAAQ,cAAeqD,OAAOxE,EAAWS,OAAS,KAC7IqF,EAAU9F,EAAcA,EAAW8F,SAAW9F,EAAW8F,UAAa,KAC5E7F,QAAQC,IAAI,wBAAyB,CACnCsK,MAAAA,EACAE,uBAAwB1K,EACxBmD,aAAcnD,EAAaA,EAAWS,KAAO,KAC7CkK,oBAAqBF,EACrBG,WAAY5K,IAAeyK,EAC3BI,cAAe/E,EAAUA,EAAQxE,OAAS,EAC1CwJ,iBAAkBhF,EAAUA,EAAQiF,MAAM,EAAG,GAAK,KAClDC,kBAAmBhL,GAAcA,EAAWc,MAAQd,EAAWc,KAAKC,eAAiBf,EAAWc,KAAKC,cAAcsD,MAC/GrE,EAAWc,KAAKC,cAAcsD,MAAMvD,KAAKiK,MAAM,EAAG,GAAG/J,IAAI,SAAAiK,GAAC,OAAIA,EAAExK,EAAE,GAClE,MAER,EAGJ,CAAE,MAAO0D,GACPlE,QAAQkE,MAAM,oCAAqCA,EACrD,CACF,E","sources":["webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/bootstrap","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/compat get default export","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/define property getters","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/hasOwnProperty shorthand","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/make namespace object","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/app']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/extend']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/PostStream']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/DiscussionPage']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadsApi.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/Post']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/ReplyComposer']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedReplyComposer.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadTree.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/index.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPost.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/SimplifiedThreadDepth.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/app'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/PostStream'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/DiscussionPage'];","/**\n * Threads API Utilities\n * \n * Simple API interface for loading threaded post data from the new\n * threadify_threads table. This replaces the complex dynamic threading\n * logic with efficient pre-computed thread structures.\n * \n * @author Threadify Extension\n */\n\n/**\n * Load all threads for a discussion\n * \n * Makes a single API call to get complete thread structure with all\n * posts in proper threaded order. No complex post loading or tree\n * building needed on the frontend.\n * \n * @param {number} discussionId - The discussion ID to load threads for\n * @returns {Promise<Object[]>} - Promise resolving to array of thread objects\n */\nexport function loadDiscussionThreads(discussionId) {\n  console.log(`[Threadify] Loading threads for discussion ${discussionId}`);\n  \n  // Use Flarum's request method to call our custom API endpoint\n  return app.request({\n    method: 'GET',\n    url: app.forum.attribute('apiUrl') + '/discussions/' + discussionId + '/threads'\n  }).then(response => {\n    console.log(`[Threadify] Loaded ${response.data.length} thread entries`);\n    \n    // Process included data first to populate the store\n    if (response.included) {\n      console.log(`[Threadify] Processing ${response.included.length} posts`);\n      response.included\n        .filter(item => item && item.type && item.id) // Filter out null/invalid items\n        .forEach(item => {\n          app.store.pushObject(item);\n        });\n    }\n    \n    // Convert thread data to posts with threading metadata\n    const postsFromApi = response.data.map(threadData => {\n      const postId = threadData.attributes.postId;\n      let post = app.store.getById('posts', postId);\n\n      if (post) {\n        post._threadDepth = threadData.attributes.depth;\n        post._threadPath = threadData.attributes.threadPath;\n        post._isRoot = threadData.attributes.isRoot;\n        post._childCount = threadData.attributes.childCount;\n        post._descendantCount = threadData.attributes.descendantCount;\n        post._rootPostId = threadData.attributes.rootPostId;\n        post._parentPostId = threadData.attributes.parentPostId;\n      }\n\n      return post;\n    }).filter(post => post !== null);\n\n    // API returns threads in correct threaded order (backend getDiscussionThreads).\n    // Use that order as-is; no frontend reordering.\n    console.log(`[Threadify] Processed ${postsFromApi.length} threaded posts (API order)`);\n    return postsFromApi;\n  }).catch(error => {\n    console.error('[Threadify] Failed to load discussion threads:', error);\n    \n    // Fallback: return empty array - existing PostStream will handle this gracefully\n    return [];\n  });\n}\n\n/**\n * Check if threads API is available for a discussion.\n *\n * Modes (configured in admin):\n * - syntaxoutlaw-threadify.mode = \"default\" (or unset):\n *     Thread all discussions.\n * - syntaxoutlaw-threadify.mode = \"tag\":\n *     Only thread discussions that have the secondary tag with slug \"threadify\".\n *\n * We emit console logs so you can see exactly what mode was detected,\n * what tags were found, and why a particular discussion was threaded or not.\n *\n * @param {Discussion} discussion - The discussion to check\n * @returns {boolean} - True if threads API should be used\n */\nexport function shouldUseThreadsApi(discussion) {\n  // Gracefully handle missing discussion (e.g. during early lifecycle)\n  if (!discussion) {\n    console.log('[Threadify] shouldUseThreadsApi: no discussion, returning false');\n    return false;\n  }\n\n  // Read the mode and tag settings from forum attributes (exposed via Extend\\Settings)\n  const rawMode =\n    app.forum && typeof app.forum.attribute === 'function'\n      ? app.forum.attribute('threadifyMode')\n      : null;\n  const mode = rawMode || 'default';\n  \n  const configuredTag =\n    app.forum && typeof app.forum.attribute === 'function'\n      ? app.forum.attribute('threadifyTag')\n      : null;\n  const threadifyTag = configuredTag || 'threadify'; // Default to 'threadify' for backward compatibility\n\n  console.log(\n    '[Threadify] shouldUseThreadsApi:',\n    'discussion id =',\n    typeof discussion.id === 'function' ? discussion.id() : discussion.id,\n    'mode from setting =',\n    rawMode,\n    'effective mode =',\n    mode,\n    'configured tag =',\n    threadifyTag\n  );\n\n  // Default behavior: thread all discussions\n  if (mode === 'default') {\n    console.log('[Threadify] shouldUseThreadsApi: mode=default → threading ENABLED for all discussions');\n    return true;\n  }\n\n  // Tag-based behavior: only thread discussions with the configured tag\n  if (mode === 'tag') {\n    // If the tags extension is not present, or tags are not loaded, just don't thread.\n    let tags = [];\n\n    // Preferred: use the discussion.tags() relationship provided by flarum/tags\n    if (typeof discussion.tags === 'function') {\n      const rel = discussion.tags();\n      if (Array.isArray(rel)) {\n        tags = rel;\n      }\n    } else if (discussion.data && discussion.data.relationships && discussion.data.relationships.tags) {\n      // Fallback: raw relationship data, resolve through the store if possible\n      const rel = discussion.data.relationships.tags.data || [];\n      tags = rel\n        .map(tagRel => {\n          if (!tagRel || !tagRel.id) return null;\n          return app.store && app.store.getById ? app.store.getById('tags', tagRel.id) : null;\n        })\n        .filter(tag => tag);\n    }\n\n    if (!tags || !tags.length) {\n      console.log('[Threadify] shouldUseThreadsApi: mode=tag but discussion has no tags → threading DISABLED');\n      return false;\n    }\n\n    // Compute a debug list of tag slugs\n    const tagSlugs = tags.map(t => {\n      if (!t) return '(null)';\n      if (typeof t.slug === 'function') return t.slug();\n      if (t.slug) return t.slug;\n      if (t.data && t.data.attributes && t.data.attributes.slug) return t.data.attributes.slug;\n      return '(unknown)';\n    });\n\n    // Check for the configured tag\n    const hasConfiguredTag = tagSlugs.includes(threadifyTag);\n\n    console.log(\n      '[Threadify] shouldUseThreadsApi: mode=tag, configured tag =',\n      threadifyTag,\n      'discussion tags =',\n      tagSlugs,\n      '→ hasConfiguredTag =',\n      hasConfiguredTag\n    );\n\n    return hasConfiguredTag;\n  }\n\n  // Unknown mode: be conservative and disable threading to avoid surprises\n  console.log('[Threadify] shouldUseThreadsApi: unknown mode value', mode, '→ threading DISABLED');\n  return false;\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts threading information that was added by loadDiscussionThreads\n * \n * @param {Post} post - The post to get metadata for\n * @returns {Object|null} - Thread metadata or null if not available\n */\nexport function getPostThreadMetadata(post) {\n  if (!post || typeof post._threadDepth === 'undefined') {\n    return null;\n  }\n  \n  return {\n    depth: post._threadDepth,\n    threadPath: post._threadPath,\n    isRoot: post._isRoot,\n    childCount: post._childCount,\n    descendantCount: post._descendantCount,\n    rootPostId: post._rootPostId\n  };\n}\n\n/**\n * Check if a post has threading metadata\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post has threading metadata\n */\nexport function hasThreadMetadata(post) {\n  return post && typeof post._threadDepth !== 'undefined';\n} ","/**\n * Threaded PostStream Component\n * \n * Instead of dynamic tree building and complex caching, this simply calls\n * the threads API to get pre-computed thread structures.\n * \n * Benefits:\n * - Single API call instead of multiple post loading calls  \n * - No complex caching or state management\n * - No dynamic tree building on frontend\n * - Much more reliable and performant\n * - Easier to understand and maintain\n * \n * @author Threadify Extension\n */\n\nimport app from 'flarum/forum/app';\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport DiscussionPage from 'flarum/forum/components/DiscussionPage';\nimport { loadDiscussionThreads, shouldUseThreadsApi } from '../utils/ThreadsApi';\n\nlet threadsLoaded = false;\nlet threadedPosts = null;\nlet currentDiscussionId = null;\nlet lastPostCount = 0;\n\nfunction sameDiscussion(a, b) {\n  return a != null && b != null && String(a) === String(b);\n}\n\n/**\n * Apply threaded order by updating the discussion model's posts relationship.\n * Flarum's postIds() reads from discussion.data.relationships.posts.data,\n * so we set that to our ordered list of { type, id } — no method override.\n */\nfunction applyThreadedOrderToDiscussion(discussionId, postsInOrder) {\n  if (!postsInOrder || !postsInOrder.length) return;\n  const discussion =\n    app.store.getById('discussions', String(discussionId)) ||\n    app.store.getById('discussions', Number(discussionId));\n  if (!discussion) {\n    if (typeof window !== 'undefined' && window.threadifyDebug) {\n      console.warn('[Threadify] Discussion not in store:', discussionId, 'store keys:', app.store.data?.discussions ? Object.keys(app.store.data.discussions) : []);\n    }\n    return;\n  }\n  const data = postsInOrder.map(p => ({\n    type: 'posts',\n    id: String(typeof p.id === 'function' ? p.id() : p.id)\n  }));\n  if (!discussion.data.relationships) discussion.data.relationships = {};\n  discussion.data.relationships.posts = { data };\n  discussion.freshness = new Date();\n\n  // Force the stream to report \"viewing end\" so core shows the reply placeholder.\n  const stream = app.current.get('stream');\n  if (stream && stream.discussion === discussion) {\n    stream.viewingEnd = function() {\n      return true;\n    };\n  }\n}\n\nfunction loadThreadsForDiscussion(discussionId) {\n  if (!discussionId) return;\n  currentDiscussionId = discussionId;\n  threadsLoaded = false;\n  threadedPosts = null;\n  loadDiscussionThreads(discussionId)\n    .then(posts => {\n      if (!sameDiscussion(currentDiscussionId, discussionId)) return;\n      threadedPosts = posts || [];\n      threadsLoaded = true;\n      lastPostCount = threadedPosts.filter(p => p).length;\n      applyThreadedOrderToDiscussion(discussionId, threadedPosts);\n      m.redraw();\n    })\n    .catch(() => {\n      threadsLoaded = true;\n      threadedPosts = null;\n      m.redraw();\n    });\n}\n\n/**\n * Initialize the Threaded PostStream\n *\n * When the threads API returns, we update the discussion model's posts relationship\n * to the threaded order. Flarum's stream uses discussion.postIds() (which reads\n * that relationship), so no overrides — we just set the right data.\n */\nexport function initThreadedPostStream() {\n  extend(DiscussionPage.prototype, 'show', function(original) {\n    return function(discussion) {\n      original.call(this, discussion);\n      if (!this.stream || !this.stream.discussion) return;\n      const discussionModel = this.stream.discussion;\n      const discussionId = discussionModel.id();\n      if (!sameDiscussion(currentDiscussionId, discussionId)) {\n        currentDiscussionId = discussionId;\n        threadsLoaded = false;\n        threadedPosts = null;\n      }\n      if (shouldUseThreadsApi(discussionModel)) {\n        loadThreadsForDiscussion(discussionId);\n      }\n    };\n  });\n\n  extend(PostStream.prototype, 'oninit', function() {\n    const stream = this.stream;\n    if (!stream || !stream.discussion) return;\n    const discussionId = stream.discussion.id();\n    if (!sameDiscussion(currentDiscussionId, discussionId)) {\n      currentDiscussionId = discussionId;\n      threadsLoaded = false;\n      threadedPosts = null;\n    }\n    if (shouldUseThreadsApi(stream.discussion)) {\n      // Force \"viewing end\" so core shows the reply placeholder (our comment-only order breaks viewingEnd).\n      stream.viewingEnd = function() {\n        return true;\n      };\n      if (!threadsLoaded) {\n        loadThreadsForDiscussion(discussionId);\n      }\n    }\n  });\n\n  extend(PostStream.prototype, 'onupdate', function() {\n    if (!shouldUseThreadsApi(this.stream.discussion)) return;\n    const stream = this.stream;\n    const count = stream.discussion ? (stream.discussion.postIds() || []).length : 0;\n    if (count !== lastPostCount) {\n      lastPostCount = count;\n      threadsLoaded = false;\n      threadedPosts = null;\n      loadThreadsForDiscussion(stream.discussion.id());\n    }\n  });\n}\n\n/**\n * Get current threading state (for debugging)\n * \n * @returns {Object} - Current state information\n */\nexport function getThreadingState() {\n  return {\n    threadsLoaded,\n    hasThreadedPosts: !!threadedPosts,\n    threadedPostCount: threadedPosts ? threadedPosts.length : 0,\n    currentDiscussionId\n  };\n}\n\n/**\n * Force reload threads for current discussion\n * \n * Useful for testing or when posts are added/modified\n */\nexport function reloadThreads() {\n  threadsLoaded = false;\n  threadedPosts = null;\n  if (currentDiscussionId) loadThreadsForDiscussion(currentDiscussionId);\n  m.redraw();\n}\n\n/**\n * Check if threading is currently active\n * \n * @returns {boolean} - True if threading is active\n */\nexport function isThreadingActive() {\n  return threadsLoaded && !!threadedPosts;\n} ","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/Post'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/ReplyComposer'];","/**\n * Threaded Reply Composer Extensions\n * \n * Handles ReplyComposer component extensions for threading functionality.\n * This module is responsible for:\n * - Extracting parent_id from post mentions in reply content\n * - Adding parent_id to the reply data before submission\n * - Integrating with Flarum's mentions extension for seamless threading\n * \n * The threading system works by detecting post mentions in the format:\n * @\"Display Name\"#p123 where 123 is the post ID that becomes the parent_id\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport ReplyComposer from 'flarum/forum/components/ReplyComposer';\n\n/**\n * Initialize ReplyComposer component extensions for threading\n * \n * Sets up hooks to automatically detect and add parent_id relationships\n * when users reply to specific posts using the mentions system.\n * \n * Note: We always extract and save parent_id from mentions, regardless of\n * whether Threadify is currently active for the discussion. This ensures\n * that threading relationships are preserved if Threadify is enabled later,\n * or if the discussion mode changes from \"tag\" to \"default\".\n */\nexport function initThreadedReplyComposer() {\n  // Hook into reply submission to add parent_id\n  extend(ReplyComposer.prototype, 'data', function(data) {\n    // Always extract parent_id from mentions - it's useful metadata regardless of threading mode\n    const parentId = extractParentIdFromContent(data.content);\n    \n    if (parentId) {\n      // Add parent_id directly to the data object\n      data.parent_id = parentId;\n      console.log('[Threadify] Reply threading to post', parentId);\n    }\n    \n    return data;\n  });\n}\n\n/**\n * Extract parent post ID from reply content\n * \n * Parses the reply content for post mentions from the mentions extension\n * and extracts the post ID to use as parent_id for threading.\n * \n * Supported mention formats:\n * - @\"Display Name\"#p123 (standard post mention)\n * - Multiple mentions (uses the first one found)\n * \n * @param {string} content - The reply content to parse\n * @returns {number|null} - The parent post ID or null if none found\n */\nexport function extractParentIdFromContent(content) {\n  if (!content || typeof content !== 'string') {\n    return null;\n  }\n  \n  // Parse the content for post mentions from the mentions extension\n  // Format: @\"Display Name\"#p123 where 123 is the post ID\n  const postMentionMatch = content.match(/@\"[^\"]*\"#p(\\d+)/);\n  \n  if (postMentionMatch && postMentionMatch[1]) {\n    const parentId = parseInt(postMentionMatch[1], 10);\n    \n    // Validate that it's a valid number\n    if (!isNaN(parentId) && parentId > 0) {\n      return parentId;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract all mentioned post IDs from content\n * \n * Gets all post mentions from the content, not just the first one.\n * Useful for analytics or advanced threading features.\n * \n * @param {string} content - The reply content to parse\n * @returns {number[]} - Array of mentioned post IDs\n */\nexport function extractAllMentionedPostIds(content) {\n  if (!content || typeof content !== 'string') {\n    return [];\n  }\n  \n  const postMentionRegex = /@\"[^\"]*\"#p(\\d+)/g;\n  const matches = [];\n  let match;\n  \n  while ((match = postMentionRegex.exec(content)) !== null) {\n    const postId = parseInt(match[1], 10);\n    if (!isNaN(postId) && postId > 0) {\n      matches.push(postId);\n    }\n  }\n  \n  return matches;\n}\n\n/**\n * Check if content contains post mentions\n * \n * @param {string} content - The content to check\n * @returns {boolean} - True if content contains post mentions\n */\nexport function hasPostMentions(content) {\n  return extractParentIdFromContent(content) !== null;\n}\n\n/**\n * Get threading context from reply content\n * \n * Extracts comprehensive threading information from reply content,\n * including the primary parent and any additional mentioned posts.\n * \n * @param {string} content - The reply content to analyze\n * @returns {Object} - Threading context object\n */\nexport function getThreadingContext(content) {\n  const primaryParentId = extractParentIdFromContent(content);\n  const allMentionedIds = extractAllMentionedPostIds(content);\n  \n  return {\n    primaryParentId: primaryParentId,\n    allMentionedPostIds: allMentionedIds,\n    hasMentions: allMentionedIds.length > 0,\n    mentionCount: allMentionedIds.length,\n    isThreadedReply: primaryParentId !== null\n  };\n}\n\n/**\n * Validate threading data before submission\n * \n * Performs validation on the threading data to ensure it's valid\n * before the reply is submitted to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Validation result with isValid boolean and any error messages\n */\nexport function validateThreadingData(data) {\n  const result = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check if parent_id is present and valid\n  if (data.parent_id !== undefined) {\n    if (typeof data.parent_id !== 'number' || data.parent_id <= 0) {\n      result.isValid = false;\n      result.errors.push('Invalid parent_id: must be a positive number');\n    }\n  }\n  \n  // Check for potential threading issues\n  if (data.content && hasPostMentions(data.content)) {\n    const context = getThreadingContext(data.content);\n    \n    if (!data.parent_id && context.isThreadedReply) {\n      result.warnings.push('Content contains post mentions but no parent_id was set');\n    }\n    \n    if (context.mentionCount > 1) {\n      result.warnings.push(`Multiple post mentions found (${context.mentionCount}), only first will be used for threading`);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Clean threading data for submission\n * \n * Ensures threading data is properly formatted and cleaned before\n * being sent to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Cleaned data object\n */\nexport function cleanThreadingData(data) {\n  const cleanedData = { ...data };\n  \n  // Ensure parent_id is a proper integer or remove it\n  if (cleanedData.parent_id !== undefined) {\n    const parentId = parseInt(cleanedData.parent_id, 10);\n    if (!isNaN(parentId) && parentId > 0) {\n      cleanedData.parent_id = parentId;\n    } else {\n      delete cleanedData.parent_id;\n    }\n  }\n  \n  return cleanedData;\n} ","/**\n * Thread Tree Utilities\n * \n * Handles building and flattening thread tree structures from Flarum posts.\n * This module is responsible for:\n * - Building hierarchical thread structures from flat post arrays\n * - Flattening thread trees back to linear arrays in threaded order\n * - Maintaining parent-child relationships between posts\n * \n * @author Threadify Extension\n */\n\n/**\n * Build a threaded tree structure from posts\n * \n * Takes a flat array of posts and organizes them into a hierarchical tree\n * structure based on their parent_id attributes. Posts without a parent_id\n * become root posts, while posts with parent_id become children of their\n * respective parents.\n * \n * @param {Post[]} posts - All posts in the discussion\n * @returns {Post[]} - Array of root posts with _threadChildren attached\n */\nexport function buildThreadTree(posts) {\n  const tree = [];\n  const postMap = new Map();\n  const childrenMap = new Map();\n  const id = (p) => (p && typeof p.id === 'function' ? String(p.id()) : String(p));\n\n  // First pass: create post map and initialize children arrays (use string keys for consistency)\n  posts.forEach(post => {\n    if (!post) return;\n    const postId = id(post);\n    postMap.set(postId, post);\n    childrenMap.set(postId, []);\n  });\n\n  // Second pass: organize posts by parent-child relationships\n  posts.forEach(post => {\n    if (!post) return;\n    const parentId = post.attribute('parent_id') ?? post._parentPostId;\n    const parentKey = parentId != null ? String(parentId) : null;\n\n    if (parentKey && postMap.has(parentKey)) {\n      childrenMap.get(parentKey).push(post);\n    } else {\n      tree.push(post);\n    }\n  });\n\n  // Third pass: attach children to posts for easy access\n  posts.forEach(post => {\n    if (!post) return;\n    post._threadChildren = childrenMap.get(id(post)) || [];\n  });\n\n  return tree;\n}\n\n/**\n * Flatten thread tree back to linear array in threaded order\n * \n * Takes a hierarchical tree of posts and flattens it back to a linear array\n * while maintaining the threaded order (parent followed by all its children\n * recursively). This preserves the threading visual structure when posts\n * are rendered linearly.\n * \n * @param {Post[]} rootPosts - Root posts with their children attached via _threadChildren\n * @returns {Post[]} - Flattened array in threaded order\n */\nexport function flattenThreadTree(rootPosts) {\n  const result = [];\n  \n  /**\n   * Recursively add a post and all its children to the result array\n   * @param {Post} post - The post to add\n   * @param {number} depth - Current nesting depth (for potential future use)\n   */\n  function addPostAndChildren(post, depth = 0) {\n    if (!post) return;\n    \n    result.push(post);\n    \n    // Get children and sort them chronologically within each thread level\n    const children = post._threadChildren || [];\n    children.sort((a, b) => {\n      const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n      const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n      return timeA - timeB;\n    });\n    \n    // Recursively add all children\n    children.forEach(child => {\n      addPostAndChildren(child, depth + 1);\n    });\n  }\n  \n  // Sort root posts chronologically to maintain discussion flow\n  rootPosts.sort((a, b) => {\n    const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n    const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n    return timeA - timeB;\n  });\n  \n  // Add each root post and its entire thread branch\n  rootPosts.forEach(rootPost => {\n    addPostAndChildren(rootPost);\n  });\n  \n  return result;\n}\n\n/**\n * Create a threaded post array from flat posts\n * \n * Convenience function that combines buildThreadTree and flattenThreadTree\n * to convert a flat array of posts directly into threaded order.\n * \n * @param {Post[]} posts - Flat array of posts\n * @returns {Post[]} - Posts reordered in threaded structure\n */\nexport function createThreadedPosts(posts) {\n  const threadTree = buildThreadTree(posts);\n  return flattenThreadTree(threadTree);\n} ","/**\n * Thread Depth Calculator\n * \n * Handles calculating and caching thread depth for posts.\n * Thread depth determines how many levels deep a post is in a thread\n * (0 = root post, 1 = direct reply, 2 = reply to reply, etc.)\n * \n * Uses caching to avoid expensive recalculations and includes cycle detection\n * to prevent infinite loops in case of malformed parent relationships.\n * \n * @author Threadify Extension\n */\n\n// Cache for thread depth calculations to avoid recalculating\nconst threadDepthCache = new Map();\n\n// Maximum allowed thread depth to prevent excessive UI indentation\nconst MAX_THREAD_DEPTH = 10;\n\n/**\n * Calculate the thread depth of a post\n * \n * Determines how many levels deep a post is in the thread hierarchy.\n * Uses caching for performance and includes cycle detection for safety.\n * \n * @param {Post} post - The post to calculate depth for\n * @param {Post[]} allPosts - All posts in the discussion (for parent lookup)\n * @returns {number} - The depth (0 = root, 1 = direct reply, etc.)\n */\nexport function calculateThreadDepth(post, allPosts) {\n  const postId = post.id();\n  \n  // Check cache first for performance\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent_id, this is a root post (depth 0)\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Find the parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    // Parent not found, treat as root\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Cycle detection: if we're calculating depth for a post that's already\n  // in our calculation chain, we have a cycle\n  const visited = new Set();\n  const depth = calculateDepthRecursive(post, allPosts, visited);\n  \n  // Cache and return the calculated depth\n  threadDepthCache.set(postId, depth);\n  return depth;\n}\n\n/**\n * Recursive helper for depth calculation with cycle detection\n * @param {Post} post - Current post\n * @param {Post[]} allPosts - All posts for parent lookup\n * @param {Set} visited - Set of visited post IDs to detect cycles\n * @returns {number} - Calculated depth\n */\nfunction calculateDepthRecursive(post, allPosts, visited) {\n  const postId = post.id();\n  \n  // Cycle detection\n  if (visited.has(postId)) {\n    console.warn(`[Threadify] Cycle detected for post ${postId}`);\n    return 0; // Treat cyclic posts as root to break the cycle\n  }\n  \n  // Check cache\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent, this is root level\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    return 0;\n  }\n  \n  // Find parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    return 0; // Parent not found, treat as root\n  }\n  \n  // Add current post to visited set\n  visited.add(postId);\n  \n  // Recursively calculate parent's depth\n  const parentDepth = calculateDepthRecursive(parentPost, allPosts, visited);\n  const depth = parentDepth + 1;\n  \n  // Remove from visited set (backtrack)\n  visited.delete(postId);\n  \n  // Apply maximum depth limit to prevent excessive UI indentation\n  return Math.min(depth, MAX_THREAD_DEPTH);\n}\n\n/**\n * Clear the thread depth cache\n * \n * Should be called when posts are updated, removed, or when switching discussions\n * to ensure fresh calculations.\n */\nexport function clearThreadDepthCache() {\n  threadDepthCache.clear();\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * Generates appropriate CSS classes for styling threaded posts.\n * \n * @param {Post} post - The post to generate classes for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {string[]} - Array of CSS classes\n */\nexport function getThreadCssClasses(post, allPosts) {\n  const threadDepth = calculateThreadDepth(post, allPosts);\n  const classes = [];\n  \n  if (threadDepth > 0) {\n    classes.push('Post--threaded');\n    classes.push(`Post--thread-depth-${threadDepth}`);\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * @param {Post} post - The post to check\n * @returns {boolean} - True if the post is a root post\n */\nexport function isRootPost(post) {\n  return !post.attribute('parent_id');\n}\n\n/**\n * Check if a post is a direct reply (depth 1)\n * @param {Post} post - The post to check\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if the post is a direct reply\n */\nexport function isDirectReply(post, allPosts) {\n  return calculateThreadDepth(post, allPosts) === 1;\n} ","/**\n * Threadify Extension - Main Entry Point\n * \n * This is the main initialization file for the Threadify extension.\n * It imports and initializes all the modular components that provide\n * threading functionality to Flarum discussions.\n * \n * The extension works by:\n * 1. Intercepting PostStream to reorder posts in threaded structure\n * 2. Adding threading CSS classes to posts for visual indentation\n * 3. Extracting parent_id from post mentions in replies\n * 4. Loading missing thread context (parents/children) as needed\n * \n * Architecture:\n * - utils/: Core threading utilities (tree building, depth calculation, post loading)\n * - components/: Flarum component extensions (PostStream, Post, ReplyComposer)\n * \n * @author Threadify Extension\n * @version 1.1\n */\n\n// Import utility modules\nimport { initThreadedPostStream, getThreadingState, reloadThreads, isThreadingActive } from './components/ThreadedPostStream';\nimport { initThreadedPost } from './components/ThreadedPost';\nimport { initThreadedReplyComposer } from './components/ThreadedReplyComposer';\n\n/**\n * Initialize the Threadify extension\n * \n * This is the main entry point that sets up all threading functionality.\n * Called automatically by Flarum when the extension is loaded.\n */\napp.initializers.add('syntaxoutlaw-threadify', () => {\n  try {\n    // Initialize all threading components with simplified API-based approach\n    initThreadedPostStream();  // Threaded post threading via API\n    initThreadedPost();                  // Post CSS classes and visual elements  \n    initThreadedReplyComposer();         // Parent ID extraction from mentions\n    \n    console.log('[Threadify] Threaded extension loaded');\n    \n    // Add global debugging utilities for troubleshooting\n    window.threadifyDebug = {\n      getState: getThreadingState,\n      reload: reloadThreads,\n      isActive: isThreadingActive,\n      help: () => {\n        console.log(`\n[Threadify] Debug Commands:\n- threadifyDebug.getState() - Get current threading state\n- threadifyDebug.reload() - Force reload threads for current discussion\n- threadifyDebug.isActive() - Check if threading is currently active\n- threadifyDebug.diagnose() - Log why order might be wrong on this page\n- threadifyDebug.help() - Show this help\n        `);\n      },\n      diagnose: () => {\n        const discussion = app.current.get('discussion');\n        const state = getThreadingState();\n        const byId = discussion ? app.store.getById('discussions', String(discussion.id())) || app.store.getById('discussions', Number(discussion.id())) : null;\n        const postIds = discussion ? (discussion.postIds && discussion.postIds()) : null;\n        console.log('[Threadify] Diagnose:', {\n          state,\n          hasCurrentDiscussion: !!discussion,\n          discussionId: discussion ? discussion.id() : null,\n          discussionInStore: !!byId,\n          sameObject: discussion === byId,\n          postIdsLength: postIds ? postIds.length : 0,\n          postIdsFirstFive: postIds ? postIds.slice(0, 5) : null,\n          relationshipOrder: discussion && discussion.data && discussion.data.relationships && discussion.data.relationships.posts\n            ? discussion.data.relationships.posts.data.slice(0, 5).map(x => x.id)\n            : null\n        });\n      }\n    };\n    \n  } catch (error) {\n    console.error('[Threadify] Failed to initialize:', error);\n  }\n});\n\n/**\n * Export utility functions for external access (if needed)\n * \n * These exports allow other extensions or debugging tools to interact\n * with Threadify's internal functionality.\n */\n\n// Re-export key utility functions for external use\nexport { createThreadedPosts } from './utils/ThreadTree';\nexport { calculateThreadDepth, clearThreadDepthCache } from './utils/ThreadDepth';\nexport { extractParentIdFromContent } from './components/ThreadedReplyComposer';\nexport { getThreadedPostsCache, isThreadingActive } from './components/ThreadedPostStream';\n\n/**\n * Get extension version and status information\n * \n * Useful for debugging and admin panels.\n * \n * @returns {Object} - Extension status information\n */\nexport function getThreadifyStatus() {\n  return {\n    version: '1.1',\n    name: 'Threadify',\n    author: 'syntaxoutlaw',\n    isActive: true,\n    components: {\n      postStream: 'loaded',\n      post: 'loaded', \n      replyComposer: 'loaded'\n    },\n    features: [\n      'Post threading via mentions',\n      'Automatic parent/child post loading',\n      'Visual thread depth indication',\n      'Thread tree caching for performance'\n    ]\n  };\n}\n","/**\n * Threaded Post Component Extensions\n * \n * Handles Post component extensions for threading functionality.\n * This module is responsible for:\n * - Adding threading CSS classes to posts based on their depth\n * - Managing post-specific threading visual elements\n * - Integrating with the ThreadDepth utility for depth calculations\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport Post from 'flarum/forum/components/Post';\nimport { getThreadCssClasses } from '../utils/SimplifiedThreadDepth';\nimport { shouldUseThreadsApi } from '../utils/ThreadsApi';\n\n/**\n * Initialize Post component extensions for threading\n * \n * Sets up all the necessary hooks and extensions for the Post component\n * to display threading information properly.\n */\nexport function initThreadedPost() {\n  // Hook into Post component to add threading CSS classes\n  extend(Post.prototype, 'classes', function(classes) {\n    const post = this.attrs.post;\n    \n    // Skip processing if we don't have a valid post\n    if (!post) {\n      console.warn('[Threadify] No post in ThreadedPost.classes');\n      return classes;\n    }\n\n    // Only apply threaded CSS when Threadify is active for this discussion\n    const discussion = typeof post.discussion === 'function' ? post.discussion() : null;\n    if (!discussion || !shouldUseThreadsApi(discussion)) {\n      return classes;\n    }\n    \n    // Get threading CSS classes from simplified utility\n    const threadClasses = getThreadCssClasses(post);\n    \n    threadClasses.forEach(className => {\n      classes.push(className);\n    });\n    \n    return classes;\n  });\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts useful threading metadata from a post that can be used\n * by other components or for debugging purposes.\n * \n * @param {Post} post - The post to extract metadata from\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Object} - Thread metadata object\n */\nexport function getPostThreadMetadata(post, allPosts) {\n  if (!post) return null;\n  \n  const parentId = post.attribute('parent_id');\n  const parentPost = parentId ? allPosts.find(p => p && p.id() == parentId) : null;\n  \n  // Find direct children of this post\n  const children = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  // Calculate some thread statistics\n  const descendants = getDescendantCount(post, allPosts);\n  \n  return {\n    postId: post.id(),\n    parentId: parentId,\n    hasParent: !!parentPost,\n    parentPost: parentPost,\n    directChildren: children,\n    childrenCount: children.length,\n    descendantCount: descendants,\n    isRootPost: !parentId,\n    threadClasses: getThreadCssClasses(post, allPosts)\n  };\n}\n\n/**\n * Count all descendants (children, grandchildren, etc.) of a post\n * \n * @param {Post} post - The post to count descendants for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {number} - Total number of descendants\n */\nfunction getDescendantCount(post, allPosts) {\n  const directChildren = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  let count = directChildren.length;\n  \n  // Recursively count descendants of each child\n  directChildren.forEach(child => {\n    count += getDescendantCount(child, allPosts);\n  });\n  \n  return count;\n}\n\n/**\n * Check if a post is part of a specific thread branch\n * \n * Determines if a post is either a descendant or ancestor of another post.\n * Useful for highlighting related posts or collapsing thread branches.\n * \n * @param {Post} post1 - First post\n * @param {Post} post2 - Second post  \n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if posts are in the same thread branch\n */\nexport function arePostsInSameBranch(post1, post2, allPosts) {\n  if (!post1 || !post2 || post1.id() === post2.id()) {\n    return false;\n  }\n  \n  // Check if post1 is an ancestor of post2\n  let currentPost = post2;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post1.id()) {\n      return true; // post1 is an ancestor of post2\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  // Check if post2 is an ancestor of post1\n  currentPost = post1;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post2.id()) {\n      return true; // post2 is an ancestor of post1\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  return false;\n}\n\n/**\n * Get the root post of a thread branch\n * \n * Traces back through parent relationships to find the root post\n * of the thread branch that contains the given post.\n * \n * @param {Post} post - The post to find the root for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Post|null} - The root post of the thread branch\n */\nexport function getThreadRoot(post, allPosts) {\n  if (!post) return null;\n  \n  let currentPost = post;\n  let rootPost = post;\n  \n  // Trace back through parents until we find a post with no parent\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) {\n      rootPost = currentPost;\n      break;\n    }\n    \n    const parentPost = allPosts.find(p => p && p.id() == parentId);\n    if (!parentPost) {\n      // Parent not found, current post becomes the effective root\n      rootPost = currentPost;\n      break;\n    }\n    \n    rootPost = parentPost;\n    currentPost = parentPost;\n  }\n  \n  return rootPost;\n} ","/**\n * Simplified Thread Depth Utilities\n * \n * This replaces the complex ThreadDepth calculation logic with simple\n * utilities that use pre-computed thread depths from the threads API.\n * \n * Benefits:\n * - No expensive depth calculations on frontend\n * - No caching needed - depth is already computed\n * - More reliable since depth is calculated once on backend\n * - Simpler code with fewer edge cases\n * \n * @author Threadify Extension\n */\n\nimport { getPostThreadMetadata } from './ThreadsApi';\n\n// Maximum allowed thread depth for UI display\nconst MAX_DISPLAY_DEPTH = 10;\n\n/**\n * Get thread depth for a post\n * \n * Uses pre-computed depth from threads API metadata instead of calculating.\n * \n * @param {Post} post - The post to get depth for\n * @returns {number} - The thread depth (0 = root, 1 = reply, etc.)\n */\nexport function getThreadDepth(post) {\n  if (!post) {\n    return 0;\n  }\n  \n  // Check if post has threading metadata from threads API\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return Math.min(metadata.depth, MAX_DISPLAY_DEPTH);\n  }\n  \n  // Fallback: use old parent_id attribute if available\n  const parentId = post.attribute('parent_id');\n  if (parentId) {\n    // Simple fallback - assume depth 1 for any post with parent\n    // This is not as accurate but prevents complete failure\n    return 1;\n  }\n  \n  // No threading information available, treat as root\n  return 0;\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * @param {Post} post - The post to get CSS classes for\n * @returns {string[]} - Array of CSS class names\n */\nexport function getThreadCssClasses(post) {\n  const depth = getThreadDepth(post);\n  const classes = [];\n  \n  if (depth > 0) {\n    classes.push('threaded-post');\n    classes.push(`thread-depth-${depth}`);\n    \n    // Add general depth classes for easier styling\n    if (depth >= 3) {\n      classes.push('thread-deep');\n    }\n    if (depth >= 5) {\n      classes.push('thread-very-deep');\n    }\n  } else {\n    classes.push('thread-root');\n  }\n  \n  // Add metadata-based classes if available\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    if (metadata.isRoot) {\n      classes.push('thread-root-confirmed');\n    }\n    if (metadata.childCount > 0) {\n      classes.push('has-children');\n      classes.push(`child-count-${Math.min(metadata.childCount, 10)}`);\n    }\n    if (metadata.descendantCount > 0) {\n      classes.push('has-descendants');\n    }\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post is a root post\n */\nexport function isRootPost(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.isRoot;\n  }\n  \n  // Fallback: check if post has no parent_id\n  return !post.attribute('parent_id');\n}\n\n/**\n * Get thread root ID for a post\n * \n * @param {Post} post - The post to get root for\n * @returns {string|null} - Root post ID or null if not available\n */\nexport function getThreadRootId(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.rootPostId;\n  }\n  \n  // Fallback: if no metadata, assume the post itself is root if no parent\n  if (!post.attribute('parent_id')) {\n    return post.id();\n  }\n  \n  return null;\n}\n\n/**\n * Get child count for a post\n * \n * @param {Post} post - The post to get child count for\n * @returns {number} - Number of direct children\n */\nexport function getChildCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.childCount : 0;\n}\n\n/**\n * Get descendant count for a post\n * \n * @param {Post} post - The post to get descendant count for\n * @returns {number} - Total number of descendants (children + grandchildren + ...)\n */\nexport function getDescendantCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.descendantCount : 0;\n}\n\n/**\n * Get thread path for a post\n * \n * @param {Post} post - The post to get thread path for\n * @returns {string|null} - Thread path (e.g., \"1/5/12\") or null if not available\n */\nexport function getThreadPath(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.threadPath : null;\n} "],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","flarum","core","compat","shouldUseThreadsApi","discussion","console","log","rawMode","app","forum","attribute","mode","threadifyTag","id","tags","rel","Array","isArray","data","relationships","map","tagRel","store","getById","filter","tag","length","tagSlugs","t","slug","attributes","hasConfiguredTag","includes","getPostThreadMetadata","post","_threadDepth","depth","threadPath","_threadPath","isRoot","_isRoot","childCount","_childCount","descendantCount","_descendantCount","rootPostId","_rootPostId","threadsLoaded","threadedPosts","currentDiscussionId","lastPostCount","sameDiscussion","b","String","loadThreadsForDiscussion","discussionId","request","method","url","then","response","included","item","type","forEach","pushObject","postsFromApi","threadData","postId","_parentPostId","parentPostId","error","loadDiscussionThreads","posts","p","postsInOrder","Number","freshness","Date","stream","viewingEnd","_app$store$data","window","threadifyDebug","warn","discussions","keys","applyThreadedOrderToDiscussion","m","redraw","initThreadedPostStream","extend","DiscussionPage","original","this","discussionModel","PostStream","count","postIds","getThreadingState","hasThreadedPosts","threadedPostCount","reloadThreads","isThreadingActive","extractParentIdFromContent","content","postMentionMatch","match","parentId","parseInt","isNaN","flattenThreadTree","rootPosts","result","addPostAndChildren","push","children","_threadChildren","sort","createdAt","getTime","child","rootPost","createThreadedPosts","threadTree","tree","postMap","Map","childrenMap","set","_post$attribute","parentKey","has","buildThreadTree","threadDepthCache","MAX_THREAD_DEPTH","calculateThreadDepth","allPosts","find","calculateDepthRecursive","Set","visited","parentPost","add","Math","min","clearThreadDepthCache","clear","getThreadifyStatus","version","name","author","isActive","components","postStream","replyComposer","features","initializers","Post","classes","attrs","metadata","getThreadDepth","getThreadCssClasses","className","ReplyComposer","parent_id","getState","reload","help","diagnose","current","state","byId","hasCurrentDiscussion","discussionInStore","sameObject","postIdsLength","postIdsFirstFive","slice","relationshipOrder","x"],"ignoreList":[],"sourceRoot":""}