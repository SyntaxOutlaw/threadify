{"version":3,"file":"forum.js","mappings":"MACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3ER,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,mBCAlF,MAAM,EAA+BI,OAAOC,KAAKC,OAAO,a,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,iBCAlD,EAA+BF,OAAOC,KAAKC,OAAO,mC,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,uC,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,yB,aCiGjD,SAASC,EAAsBC,GACpC,OAAKA,QAAqC,IAAtBA,EAAKC,aAIlB,CACLC,MAAOF,EAAKC,aACZE,WAAYH,EAAKI,YACjBC,OAAQL,EAAKM,QACbC,WAAYP,EAAKQ,YACjBC,gBAAiBT,EAAKU,iBACtBC,WAAYX,EAAKY,aATV,IAWX,CC9GA,MAAM,EAA+BhB,OAAOC,KAAKC,OAAO,kC,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,+B,aCyEjD,SAASe,EAAkBC,GAChC,IAAMC,EAAS,GAOf,SAASC,EAAmBhB,EAAME,GAChC,QADqC,IAALA,IAAAA,EAAQ,GACnCF,EAAL,CAEAe,EAAOE,KAAKjB,GAGZ,IAAMkB,EAAWlB,EAAKmB,iBAAmB,GACzCD,EAASE,KAAK,SAACtC,EAAGuC,GAGhB,OAFcvC,EAAEwC,UAAYxC,EAAEwC,YAAYC,UAAY,IACxCF,EAAEC,UAAYD,EAAEC,YAAYC,UAAY,EAExD,GAGAL,EAASM,QAAQ,SAAAC,GACfT,EAAmBS,EAAOvB,EAAQ,EACpC,EAfiB,CAgBnB,CAcA,OAXAY,EAAUM,KAAK,SAACtC,EAAGuC,GAGjB,OAFcvC,EAAEwC,UAAYxC,EAAEwC,YAAYC,UAAY,IACxCF,EAAEC,UAAYD,EAAEC,YAAYC,UAAY,EAExD,GAGAT,EAAUU,QAAQ,SAAAE,GAChBV,EAAmBU,EACrB,GAEOX,CACT,CCnGA,IAAMY,EAAmB,IAAIC,IAqGtB,SAASC,IACdF,EAAiBG,OACnB,CCxGA,SAASC,EAAQC,GACf,OAAY,MAALA,EAAY,GAAKC,OAAOD,EACjC,CAOA,SAASE,EAAqBC,EAAWC,GACvC,IAAMC,EAAM,IAAIT,IAGhB,OAFAO,EAAUG,OAAOC,SAASf,QAAQ,SAACgB,GAAC,OAAKH,EAAII,IAAIV,EAAQS,EAAEE,MAAOF,EAAE,GACpEJ,EAAWE,OAAOC,SAASf,QAAQ,SAACgB,GAAC,OAAKH,EAAII,IAAIV,EAAQS,EAAEE,MAAOF,EAAE,GAC9DG,MAAMC,KAAKP,EAAIQ,SACxB,CAEA,SAASC,EAAeC,GACtB,IAAMC,GAAOD,GAAW,IAAIV,IAAIN,GAASO,OAAOC,SAChD,OAAmB,IAAfS,EAAIC,OAAqBC,QAAQC,QAAQ,IAEtCC,IAAAA,MAAUC,KAAK,QAAS,CAC7Bf,OAAQ,CAAEI,GAAIM,EAAIM,KAAK,OAG3B,CASO,SAASC,EAAuBC,EAAYC,GACjD,IAAMC,GAASD,GAAgB,IAAInB,OAAOC,SACpCoB,EAAe,IAAIC,IAAIF,EAAMrB,IAAI,SAACG,GAAC,OAAKT,EAAQS,EAAEE,KAAK,IACvDmB,EAAmB,GAEzBH,EAAMlC,QAAQ,SAACgB,GACb,IAAMsB,EAAM/B,EAAS,MAADS,GAAY,MAAZA,EAAGuB,eAAS,EAAZvB,EAAGuB,UAAY,cAC/BD,IAAQH,EAAaK,IAAIF,IAAMD,EAAiB5C,KAAK6C,EAC3D,GAEA,IAAMG,EAAgBtB,MAAMC,KAAK,IAAIgB,IAAIC,IACzC,OAA6B,IAAzBI,EAAchB,OACTC,QAAQC,QAAQO,GAGlBZ,EAAemB,GACnBC,KAAK,SAACC,GACL,IAAMC,EAASlC,EAAqBwB,EAAOS,GAE3C,OAAOZ,EAAuBC,EAAYY,EAC5C,GAAE,MACK,SAACC,GAGN,OAFAC,QAAQC,KAAK,2CAA4CF,GAElDX,CACT,EACJ,C,oyBCxDA,IAAMc,EAAS,IAAI5C,IAEZ,SAAS6C,EAAoBC,GAClC,IAAMC,EAAM1C,OAAOyC,GACbE,EAAWJ,EAAOlF,IAAIqF,GAC5B,IAAwB,KAAZ,MAARC,OAAQ,EAARA,EAAUC,OAAgB,OAAO3B,QAAQC,UAC7C,GAAY,MAARyB,GAAAA,EAAUC,OAAwC,mBAAxBD,EAASC,MAAMX,KAAqB,OAAOU,EAASC,MAElF,IAAMC,EAAQ,CAAEzC,IAAK,IAAIT,IAAOiD,MAAO,MAoCvC,OAnCAL,EAAO/B,IAAIkC,EAAKG,GAEhBA,EAAMD,MAAQzB,IAAAA,QACH,CACP2B,OAAQ,MACRC,IAAQ5B,IAAAA,MAAUW,UAAU,UAAS,gBAAgBkB,mBAAmBN,GAAI,mBAE7ET,KAAK,SAACgB,GAGL,IAFA,IAEuBC,EAFjB9C,EAAM,IAAIT,IAEhBwD,EAAAC,EADa1C,MAAM2C,QAAW,MAAHJ,OAAG,EAAHA,EAAKK,OAASL,EAAIK,MAAQ,MAC9BJ,EAAAC,KAAAI,MAAE,KAAdC,EAAIN,EAAAO,MACb,GAAKD,EAAL,CACA,IAAM3B,EAAM6B,OAAOF,EAAKG,QAClBC,EAAMF,OAAOF,EAAKF,OAClBO,EAAMH,OAAOF,EAAKvF,OAClB6F,EAA8B,MAArBN,EAAKO,aAAuBL,OAAOF,EAAKO,cAAgB,KAClEL,OAAOM,MAAMnC,IAAS6B,OAAOM,MAAMJ,IACtCxD,EAAII,IAAIqB,EAAK,CACXyB,MAAOM,EACP3F,MAAOyF,OAAOM,MAAMH,GAAO,EAAIA,EAC/BI,SAAUH,GATK,CAYrB,CACAjB,EAAMzC,IAAMA,EACZyC,EAAMD,OAAQ,EAEd,IAAMsB,OAAOC,cAAc,IAAIC,YAAY,uBAAwB,CAAEC,OAAQX,OAAOhB,KAAU,CAAE,MAAA4B,GAAO,CACvG,IAAMC,WAAW,kBAAMC,EAAEC,QAAQ,EAAE,EAAI,CAAE,MAAAC,GAAO,CAClD,GAAE,MACK,SAACC,GACNtC,QAAQC,KAAK,qCAAsCqC,GACnD9B,EAAMD,OAAQ,CAChB,GAEKC,EAAMD,KACf,CAEO,SAASgC,EAAcnC,EAAckB,GAC1C,IAAMd,EAAQN,EAAOlF,IAAI2C,OAAOyC,IAChC,GAAU,MAALI,GAAAA,EAAOzC,IAAZ,CACA,IAAMyE,EAAMhC,EAAMzC,IAAI/C,IAAIqG,OAAOC,IACjC,OAAOkB,EAAMA,EAAIvB,WAAQwB,CAFQ,CAGnC,CASO,SAASC,EAAoBtC,EAAckB,GAChD,IAAMd,EAAQN,EAAOlF,IAAI2C,OAAOyC,IAChC,GAAU,MAALI,GAAAA,EAAOzC,IAAZ,CACA,IAAMyE,EAAMhC,EAAMzC,IAAI/C,IAAIqG,OAAOC,IACjC,OAAOkB,EAAMA,EAAIZ,cAAWa,CAFK,CAGnC,C,oyBCtDA,IAMIE,GAAe,EACfC,EAAsB,KACtBC,EAAgB,EAChBC,EAAsB,KACtBC,EAAsB,KAG1B,SAASC,EAAWC,GAClB,QAAKA,MAEHA,EAAMC,SACND,EAAME,iBACNF,EAAMG,aACNH,EAAMI,aACNJ,EAAMK,kBACNL,EAAMM,aAEV,CAiEA,SAASC,EAAuBtE,GAC9B,IAAIyD,EAAJ,CACAA,GAAe,EAEf,IDpC2BvC,EACrBI,ECmCAiD,EAAS,SAACC,GACdd,EAAsBc,EACtBf,GAAe,EACfT,WAAW,WAAQ,IAAMC,EAAEC,QAAU,CAAE,MAAAC,GAAO,CAAE,EAAG,EACrD,EAEA,IACE,IAAKS,EAAqB,OAAOW,EAAO,MAExC,IAAME,EAAgBb,EAAoBzH,KAAK6D,EAAW0E,SAAW,GAC/DC,EAAaF,EAAc3F,OAAOC,SACxC,GAA0B,IAAtB4F,EAAWlF,OAAc,OAAO8E,EAAO,MAE3C,IAAMpD,EAAMnB,EAAW0E,OAAOE,YAAc5E,EAAW0E,OAAOE,WAAW1F,IAAMc,EAAW0E,OAAOE,WAAW1F,KAEtG2F,EAAQ,WAAH,OAyCoB3D,EAxCHC,EAwCiBjB,EAxCZyE,EAyC5B,IAAIjF,QAAQ,SAACC,GAClB,IAAKuB,IAAiB/B,MAAM2C,QAAQ5B,IAA2B,IAAjBA,EAAMT,OAAc,OAAOE,EAAQO,GAKjF,IAHA,IAGqByB,EAHfmD,EAAS,IAAI1E,IAAIF,EAAMrB,IAAI,SAACG,GAAC,OAAKP,OAAOO,EAAEE,IAAMF,EAAEE,KAAK,IACxD6F,EAAU,IAAI3E,IAEpBwB,EAAAC,EAAgB3B,KAAKyB,EAAAC,KAAAI,MAGnB,IAHqB,IAAZhD,EAAC2C,EAAAO,MACN8C,EAAO,EACPC,EAAMjG,GAAKA,EAAEE,IAAMiD,OAAOnD,EAAEE,MACzB+F,GAAOD,EA9JO,GA8JoB,CACvC,IAAMzC,EAASiB,EAAoBtC,EAAc+D,GACjD,IAAK1C,EAAQ,MACRuC,EAAOtE,IAAI/B,OAAO8D,KAAUwC,EAAQG,IAAIzG,OAAO8D,IACpD0C,EAAM1C,EACNyC,GACF,CAGF,GAAqB,IAAjBD,EAAQI,KAAY,OAAOxF,EAAQO,GAEvCN,IAAAA,MACGC,KAAK,QAAS,CAAEf,OAAQ,CAAEI,GAAIC,MAAMC,KAAK2F,GAASjF,KAAK,QACvDY,KAAK,SAACC,GAEL,IADA,IACoCyE,EAD9BvG,EAAM,IAAIT,IAAI8B,EAAMrB,IAAI,SAACG,GAAC,MAAK,CAACP,OAAOO,EAAEE,IAAMF,EAAEE,MAAOF,EAAE,IAChEqG,EAAAxD,EAAiBlB,GAAiB,MAAEyE,EAAAC,KAAArD,MAAE,KAA3BsD,EAAEF,EAAAlD,MACLhD,EAAKT,OAAO6G,EAAGpG,IAAMoG,EAAGpG,MACzBL,EAAI2B,IAAItB,IAAKL,EAAII,IAAIC,EAAIoG,EAChC,CACA3F,EAAQR,MAAMC,KAAKP,EAAIQ,UACzB,GAAE,MACK,kBAAMM,EAAQO,EAAM,EAC/B,IAvEOQ,KAAK,SAAC6E,GAAa,OA2E5B,SAAkCrE,EAAchB,GAC9C,OAAO,IAAIR,QAAQ,SAACC,GAClB,IAAKuB,IAAiB/B,MAAM2C,QAAQ5B,IAA2B,IAAjBA,EAAMT,OAAc,OAAOE,EAAQO,GAEjF,IAAMsF,EAAY,IAAIpF,IAAIF,EAAMrB,IAAI,SAACG,GAAC,OAAKP,OAAOO,EAAEE,IAAMF,EAAEE,KAAK,IAC3DuG,EAAY,IAAIrF,IAAIF,EAAMrB,IAAI,SAACG,GAAC,OAAKA,GAAKA,EAAEE,IAAMiD,OAAOnD,EAAEE,KAAK,IAEhEwG,EDzHH,SAAsCxE,EAAcuE,EAAWE,EAAoBC,EAAiBC,QAAvB,IAAdF,IAAAA,EAAiB,QAAO,IAAJC,IAAAA,EAAO,eAAkB,IAARC,IAAAA,EAAW,IACpH,IAAMvE,EAAQN,EAAOlF,IAAI2C,OAAOyC,IAChC,GAAU,MAALI,IAAAA,EAAOzC,MAAQ4G,EAAW,MAAO,GAEtC,IAAMK,EAAO,IAAI1F,IAAI,GAAA2F,OAAIN,GAAW5G,IAAI,SAACL,GAAC,OAAK2D,OAAO3D,EAAE,IACxD,GAAkB,IAAdsH,EAAKX,KAAY,MAAO,GAI5B,IADA,IAC+CC,EADzCY,EAAU,IAAI5H,IACpBiH,EAAAxD,EAA4BP,EAAMzC,IAAIoH,aAASb,EAAAC,KAAArD,MAAE,KAAAkE,EAAAd,EAAAlD,MAArCE,EAAM8D,EAAA,GAAE5C,EAAG4C,EAAA,GACf5F,EAAS,MAAHgD,OAAG,EAAHA,EAAKZ,SACjB,GAAKpC,GAAQwF,EAAKtF,IAAIF,GAAtB,CACA,IAAIkE,EAAMwB,EAAQlK,IAAIwE,GACjBkE,IAAOA,EAAM,GAAIwB,EAAQ/G,IAAIqB,EAAKkE,IACvCA,EAAI/G,KAAK,CAAE2E,OAAQD,OAAOC,GAASL,MAAOuB,EAAIvB,OAAS,GAHnB,CAItC,CAIA,IADA,IAC0CoE,EADpCC,EAAM,GACZC,EAAAxE,EAAyBmE,EAAQC,aAASE,EAAAE,KAAArE,MAAE,KAAAsE,EAAAH,EAAAjE,MAA3BsC,GAAF8B,EAAA,GAAKA,EAAA,IAClB9B,EAAI5G,KAAK,SAACtC,EAAGuC,GAAC,OAAKvC,EAAEyG,MAAQlE,EAAEkE,KAAK,GAEpC,IADA,IACuBwE,EAAvBC,EAAA3E,EADwB,aAAT+D,EAAsBpB,EAAIiC,MAAM,EAAGd,GAAkBnB,EAAIiC,OAAOd,MACxDY,EAAAC,KAAAxE,MAAE,KAAd0E,EAAEH,EAAArE,MAAYkE,EAAI3I,KAAKiJ,EAAGtE,OAAO,CAC5C,GAAIgE,EAAI3G,QAAUoG,EAAU,KAC9B,CAGA,OAAO1G,MAAMC,KAAK,IAAIgB,IAAIgG,IAAMK,MAAM,EAAGZ,EAC3C,CC6FwBc,CAClBzF,EACAuE,EAhMyB,EAkMzB,SAjMkB,IAsMdV,EAAUW,EAAY5G,OAAO,SAACI,GAAE,OAAMsG,EAAUhF,IAAI/B,OAAOS,GAAI,GACrE,GAAuB,IAAnB6F,EAAQtF,OAAc,OAAOE,EAAQO,GAEzCN,IAAAA,MACGC,KAAK,QAAS,CAAEf,OAAQ,CAAEI,GAAI6F,EAAQjF,KAAK,QAC3CY,KAAK,SAACkG,GAAc,OAAKjH,EAAQ,GAADoG,OAAK7F,EAAW0G,GAAkB,IAAK,GAAC,MAClE,kBAAMjH,EAAQO,EAAM,EAC/B,EACF,CAnGiC2G,CAAyB1F,EAAKoE,EAAc,GACpE7E,KAAK,SAACW,GACL,IAAMyF,EAoGhB,SAA6B5F,EAAchB,GACzC,IAAKgB,IAAiB/B,MAAM2C,QAAQ5B,IAA2B,IAAjBA,EAAMT,OAAc,OAAO,KAEzE,IADYS,EAAM6G,KAAK,SAAC/H,GAAC,OAAoD,MAA/CqE,EAAcnC,EAAclC,EAAEE,IAAMF,EAAEE,KAAa,GACvE,OAAO,KAEjB,IAAM8H,EAAO9G,EAAMuG,QAgBnB,OAfAO,EAAKpJ,KAAK,SAACtC,EAAGuC,GACZ,IAAMoJ,EAAM3L,GAAKA,EAAE4D,IAAM5D,EAAE4D,KACrBgI,EAAMrJ,GAAKA,EAAEqB,IAAMrB,EAAEqB,KACrBiI,EAAK9D,EAAcnC,EAAc+F,GACjCG,EAAK/D,EAAcnC,EAAcgG,GAEvC,GAAU,MAANC,GAAoB,MAANC,EAAY,CAC5B,GAAU,MAAND,GAAoB,MAANC,EAAY,OAAO,EACrC,GAAU,MAAND,EAAY,OAAO,EACvB,GAAU,MAANC,EAAY,OAAQ,EACxB,GAAID,IAAOC,EAAI,OAAOD,EAAKC,CAC7B,CACA,OAAO,CACT,GAEOJ,CACT,CA1HyBK,CAAoBlG,EAAKE,GACxC,GAAIyF,GAAUA,EAAOrH,OAArB,CACE,IAAM6H,EAAgBC,EAAiBT,EAAQrC,EAAchF,QAC7D8E,EAAO+C,EAET,MAgIV,SAA6BtH,EAAYE,GAGrC,OAAOH,EADKC,EAAW4E,WAAa5E,EAAa,CAAE4E,WAAY5E,EAAW0E,OAAOE,YAC9C1E,GAAM,MAAO,kBAAMsH,EAAoBtH,EAAM,EAGpF,EAnIUuH,CAAoBzH,EAAY2E,GAC7BjE,KAAK,SAACgH,GAAgB,OAoInC,SAA+B1H,EAAYE,GAGvC,OF3MG,SAA6BF,EAAYC,GAC9C,IAAM2E,EAhER,SAA2B5E,GAAY,IAAA2H,EAErC,OAAiB,MAAV3H,OAAU,EAAVA,EAAY4E,cAAwB,MAAV5E,GAAkB,OAAR2H,EAAV3H,EAAY0E,aAAM,EAAlBiD,EAAoB/C,aAAc,IACrE,CA6DqBgD,CAAkB5H,GAC/BE,GAASD,GAAgB,IAAInB,OAAOC,SACpCoB,EAAe,IAAIC,IAAIF,EAAMrB,IAAI,SAACG,GAAC,OAAKT,EAAQS,EAAEE,KAAK,IAE7D,IAAK0F,GAA4C,mBAAvBA,EAAWrF,QACnC,OAAOG,QAAQC,QAAQO,GAGzB,IACM2H,GADqBjD,EAAWrF,WAAa,IAAIV,IAAIN,GACrBO,OAAO,SAACI,GAAE,OAAKA,IAAOiB,EAAaK,IAAItB,EAAG,GAEhF,GAA2B,IAAvB2I,EAAYpI,OACd,OAAOC,QAAQC,QAAQO,GAGzB,IAAM4H,EAAaC,KAAKC,IAAI,GAAIH,EAAYpI,QAG5C,OAAOH,EAFgBuI,EAAYpB,OAAOqB,IAGvCpH,KAAK,SAACuH,GAEL,IAAMC,GAAkBD,GAAgB,IAAInJ,OAAO,SAACE,GAClD,IAAMsB,EAAM/B,EAAS,MAADS,GAAY,MAAZA,EAAGuB,eAAS,EAAZvB,EAAGuB,UAAY,cACnC,OAAOD,GAAOH,EAAaK,IAAIF,EACjC,GAEA,OAA8B,IAA1B4H,EAAezI,OACVS,EAEFxB,EAAqBwB,EAAOgI,EACrC,GAAE,MACK,SAACrH,GAEN,OADAC,QAAQC,KAAK,0CAA2CF,GACjDX,CACT,EACJ,CEuKWiI,CADKnI,EAAW4E,WAAa5E,EAAa,CAAE4E,WAAY5E,EAAW0E,OAAOE,YACjD1E,GAAM,MAAO,kBAAMA,CAAK,EAG5D,CAxIkBkI,CAAsBpI,EAAY0H,EAClB,GAErBhH,KAAK,SAAC2H,GACL,IACMf,EAAgBC,EJ/B7B,SAA6BrH,GAClC,IAAMoI,EAtGD,SAAyBpI,GAC9B,IAAMqI,EAAO,GACPC,EAAU,IAAIpK,IACdqK,EAAc,IAAIrK,IAiCxB,OA9BA8B,EAAMlC,QAAQ,SAAAxB,GACZ,GAAKA,EAAL,CAEA,IAAM4F,EAAS5F,EAAK0C,KACpBsJ,EAAQvJ,IAAImD,EAAQ5F,GACpBiM,EAAYxJ,IAAImD,EAAQ,GAJP,CAKnB,GAGAlC,EAAMlC,QAAQ,SAAAxB,GACZ,GAAKA,EAAL,CAEeA,EAAK0C,KAApB,IACMwD,EAAWlG,EAAK+D,UAAU,aAE5BmC,GAAY8F,EAAQhI,IAAI/B,OAAOiE,IAEjC+F,EAAY3M,IAAI2C,OAAOiE,IAAWjF,KAAKjB,GAGvC+L,EAAK9K,KAAKjB,EAVK,CAYnB,GAGA0D,EAAMlC,QAAQ,SAAAxB,GACPA,IACLA,EAAKmB,gBAAkB8K,EAAY3M,IAAIU,EAAK0C,OAAS,GACvD,GAEOqJ,CACT,CAiEqBG,CAAgBxI,GACnC,OAAO7C,EAAkBiL,EAC3B,CI2B+BK,CAAoBN,GACY5D,EAAchF,QAC/D8E,EAAO+C,EACT,GAAE,MACK,SAACzG,GACNC,QAAQC,KAAK,yDAA0DF,GACvE0D,EAAO,KACT,EACJ,GAcR,IAAmCrD,EAAchB,CAdvC,EAEFiB,IDhFqBD,ECgFAC,ID/ErBG,EAAQN,EAAOlF,IAAI2C,OAAOyC,OACG,IAAhBI,EAAMD,OC+ErBJ,EAAoBE,GAAI,QAAS0D,GAEjCA,GAEJ,CAAE,MAAOzB,GACPtC,QAAQ8H,MAAM,6CAA8CxF,GAC5DK,GAAe,CACjB,CAvDwB,CAwD1B,CA2FA,SAAS8D,EAAiB/C,EAAKqE,GAG7B,IAFA,IAAMtL,EAAS4B,MAAM2C,QAAQ0C,GAAOA,EAAIiC,QAAU,GAC5CqC,EAAOf,KAAKgB,IAAI,EAAGF,EAAYtL,EAAOkC,QACnCuJ,EAAI,EAAGA,EAAIF,EAAME,IAAKzL,EAAOE,KAAK,MAC3C,OAAOF,CACT,CAmBA,SAASiK,EAAoBvH,GAC3B,IAAMgJ,EAAO,IAAI7K,IAAI6B,EAAanB,OAAOC,SAASF,IAAI,SAACG,GAAC,MAAK,CAACP,OAAOO,EAAEE,MAAOF,EAAE,IAC1EkK,EAAU,GAKhB,OAJAjJ,EAAajC,QAAQ,SAACgB,GACpB,IAAMsB,EAAMtB,GAAKA,EAAEuB,UAAYvB,EAAEuB,UAAU,aAAe,KACtDD,IAAQ2I,EAAKzI,IAAI/B,OAAO6B,KAAO4I,EAAQzL,KAAKgB,OAAO6B,GACzD,GACuB,IAAnB4I,EAAQzJ,OAAqBC,QAAQC,QAAQM,GAE1CL,IAAAA,MACJC,KAAK,QAAS,CAAEf,OAAQ,CAAEI,GAAIgK,EAAQpJ,KAAK,QAC3CY,KAAK,SAACoE,GAAM,OAAK0C,EAAoB,GAADzB,OAAK9F,EAAiB6E,GAAQ,GAAC,MAC7D,kBAAM7E,CAAY,EAC7B,CClSAL,IAAAA,aAAiBsF,IAAI,yBAA0B,YCa7CiE,EAAAA,EAAAA,QAAOC,IAAAA,UAAgB,UAAW,SAASC,GACzC,IAAM7M,EAAO8M,KAAKC,MAAM/M,KAGxB,IAAKA,EAEH,OADAsE,QAAQC,KAAK,+CACNsI,EAIT,IAAMG,ECuBH,SAA6BhN,GAClC,IAAME,EA9BD,SAAwBF,GAC7B,IAAKA,EACH,OAAO,EAIT,IAAMiN,EAAWlN,EAAsBC,GACvC,OAAIiN,EACK1B,KAAKC,IAAIyB,EAAS/M,MAlBH,IAsBPF,EAAK+D,UAAU,aAIvB,EAIF,CACT,CASgBmJ,CAAelN,GACvB6M,EAAU,GAEZ3M,EAAQ,GACV2M,EAAQ5L,KAAK,iBACb4L,EAAQ5L,KAAK,gBAAgBf,GAGzBA,GAAS,GACX2M,EAAQ5L,KAAK,eAEXf,GAAS,GACX2M,EAAQ5L,KAAK,qBAGf4L,EAAQ5L,KAAK,eAIf,IAAMgM,EAAWlN,EAAsBC,GAcvC,OAbIiN,IACEA,EAAS5M,QACXwM,EAAQ5L,KAAK,yBAEXgM,EAAS1M,WAAa,IACxBsM,EAAQ5L,KAAK,gBACb4L,EAAQ5L,KAAK,eAAesK,KAAKC,IAAIyB,EAAS1M,WAAY,MAExD0M,EAASxM,gBAAkB,GAC7BoM,EAAQ5L,KAAK,oBAIV4L,CACT,CD1D0BM,CAAoBnN,GAO1C,OANAsE,QAAQ8I,IAAI,sCAAsCpN,EAAK0C,KAAI,KAAKsK,EAAc1J,KAAK,OAEnF0J,EAAcxL,QAAQ,SAAA6L,GACpBR,EAAQ5L,KAAKoM,EACf,GAEOR,CACT,IEhBAF,EAAAA,EAAAA,QAAOW,IAAAA,UAAyB,OAAQ,SAASC,GAC/C,IAAMrH,EAyBH,SAAoCsH,GACzC,IAAKA,GAA8B,iBAAZA,EACrB,OAAO,KAKT,IAAMC,EAAmBD,EAAQE,MAAM,mBAEvC,GAAID,GAAoBA,EAAiB,GAAI,CAC3C,IAAMvH,EAAWyH,SAASF,EAAiB,GAAI,IAG/C,IAAKxH,MAAMC,IAAaA,EAAW,EACjC,OAAOA,CAEX,CAEA,OAAO,IACT,CA5CqB0H,CAA2BL,EAAKC,SAQjD,OANItH,IAEFqH,EAAKM,UAAY3H,EACjB5B,QAAQ8I,IAAI,sCAAuClH,IAG9CqH,CACT,GJoBK,WAAkC,IAAAO,EAAA,MACvCnB,EAAAA,EAAAA,QAAOoB,IAAAA,UAAsB,SAAU,WAAY,IAAAC,EAAA,KAC3CrJ,EAAMmI,KAAK5E,OAAOE,YAAc0E,KAAK5E,OAAOE,WAAW1F,IAAMoK,KAAK5E,OAAOE,WAAW1F,KACtF2E,IAAwB1C,IA2Q9B0C,EA3Q8C1C,EA4Q9CsC,GAAe,EACfC,EAAsB,KACtBC,EAAgB,EAChBC,EAAsB,KACtBvF,KA9QOuF,IAAqBA,EAAsB0F,KAAK5E,OAAOxE,OAExDiB,GAAKF,EAAoBE,GAE7BmI,KAAK5E,OAAOxE,MAAQ,WAClB,GAAIwD,EAAqB,OAAOA,EAEhC,IAAM+G,EAAW7G,EAAoBzH,KAAKqO,EAAK9F,SAAW,GAI1D,OAHKjB,GAAgBgH,EAAS3L,OAAOC,SAASU,OAAS,GACrD6E,EAAuBkG,GAElBC,CACT,EAEA,IAAMxF,EAAMrB,EAAoBzH,KAAKmN,KAAK5E,SAAW,IACrDf,EAAgBsB,EAAInG,OAAOC,SAASU,QAChB,GAAG6E,EAAuBgF,KAChD,IAEAH,EAAAA,EAAAA,QAAOoB,IAAAA,UAAsB,WAAY,WAAY,IAAAG,EAAA,KACnD,GAAK9G,EAAL,CAEA,IACM+G,GADU/G,EAAoBzH,KAAKmN,KAAK5E,SAAW,IACnC5F,OAAOC,SAASU,OAElCkL,IAAUhH,IACZA,EAAgBgH,EAChBjH,EAAsB,KACtBrF,IAEKyF,EAAWwF,KAAK5E,QAGnB1B,WAAW,WACJc,EAAW4G,EAAKhG,SAASJ,EAAuBoG,EACvD,EAAG,IAJHpG,EAAuBgF,MAXK,CAkBlC,GAGA3G,OAAOiI,iBAAiB,uBAAwB,SAACC,GAC/C,IAAM1J,EAAQ,MAAF0J,OAAE,EAAFA,EAAI/H,OACX3B,GAAOA,IAAQ0C,GACpBb,WAAW,WACT,IACOS,GAAiBC,GAAqBY,EAAuBgG,EACpE,CAAE,MAAAvH,GAAO,CACX,EAAG,EACL,EACF,CCjGE+H,IAGA3B,EAAAA,EAAAA,QAAO4B,IAAAA,UAA0B,SAAU,WACzC,IAAM5J,EAAMmI,KAAK1E,YAAc0E,KAAK1E,WAAW1F,IAAMoK,KAAK1E,WAAW1F,KACjEiC,GAAKF,EAAoBE,EAC/B,IAGAgI,EAAAA,EAAAA,QAAO6B,IAAAA,UAA8B,WAAY,WAC/C,IAAMpG,EAAa0E,KAAKC,MAAM3E,WAC9B,GAAKA,EAAL,CACA,IAAMzD,EAAMyD,EAAW1F,KACjB+L,EAAU,WAAH,OAAShK,EAAoBE,EAAI,EAE9CmI,KAAK4B,SAAW5B,KAAK4B,QAAQN,iBAAiB,aAAcK,EAAS,CAAEE,MAAM,IAC7E7B,KAAK4B,SAAW5B,KAAK4B,QAAQN,iBAAiB,aAAcK,EAAS,CAAEE,MAAM,EAAMC,SAAS,GALrE,CAMzB,EACF,E","sources":["webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/bootstrap","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/compat get default export","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/define property getters","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/hasOwnProperty shorthand","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/app']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/extend']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/DiscussionPage']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/DiscussionListItem']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/Post']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadsApi.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/ReplyComposer']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/PostStream']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadTree.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/PostLoader.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadOrderPrefetch.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/index.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPost.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/SimplifiedThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedReplyComposer.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/app'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/DiscussionPage'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/DiscussionListItem'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/Post'];","/**\n * Threads API Utilities\n * \n * Simple API interface for loading threaded post data from the new\n * threadify_threads table. This replaces the complex dynamic threading\n * logic with efficient pre-computed thread structures.\n * \n * @author Threadify Extension\n */\n\n/**\n * Load all threads for a discussion\n * \n * Makes a single API call to get complete thread structure with all\n * posts in proper threaded order. No complex post loading or tree\n * building needed on the frontend.\n * \n * @param {number} discussionId - The discussion ID to load threads for\n * @returns {Promise<Object[]>} - Promise resolving to array of thread objects\n */\nexport function loadDiscussionThreads(discussionId) {\n  console.log(`[Threadify] Loading threads for discussion ${discussionId}`);\n  \n  // Use Flarum's request method to call our custom API endpoint\n  return app.request({\n    method: 'GET',\n    url: app.forum.attribute('apiUrl') + '/discussions/' + discussionId + '/threads'\n  }).then(response => {\n    console.log(`[Threadify] Loaded ${response.data.length} thread entries`);\n    \n    // Process included data first to populate the store\n    if (response.included) {\n      console.log(`[Threadify] Processing ${response.included.length} included items`);\n      response.included.forEach(item => {\n        console.log(`[Threadify] Including ${item.type}:${item.id}`);\n        app.store.pushObject(item);\n      });\n    }\n    \n    // Convert thread data to posts with threading metadata\n    const threadedPosts = response.data.map(threadData => {\n      // Find the post in Flarum's store\n      const postId = threadData.attributes.postId;\n      let post = app.store.getById('posts', postId);\n      \n      if (post) {\n        // Debug: Check if post has user relationship\n        console.log(`[Threadify] Post ${postId} found, user:`, post.user ? post.user() : 'NO USER');\n        \n        // Add threading metadata to the post\n        post._threadDepth = threadData.attributes.depth;\n        post._threadPath = threadData.attributes.threadPath;\n        post._isRoot = threadData.attributes.isRoot;\n        post._childCount = threadData.attributes.childCount;\n        post._descendantCount = threadData.attributes.descendantCount;\n        post._rootPostId = threadData.attributes.rootPostId;\n        post._parentPostId = threadData.attributes.parentPostId;\n        \n        console.log(`[Threadify] Post ${postId} depth: ${post._threadDepth}, path: ${post._threadPath}`);\n      } else {\n        console.warn(`[Threadify] Post ${postId} not found in store`);\n      }\n      \n      return post;\n    }).filter(post => post !== null); // Filter out any null posts\n    \n    console.log(`[Threadify] Processed ${threadedPosts.length} threaded posts`);\n    \n    return threadedPosts;\n  }).catch(error => {\n    console.error('[Threadify] Failed to load discussion threads:', error);\n    \n    // Fallback: return empty array - existing PostStream will handle this gracefully\n    return [];\n  });\n}\n\n/**\n * Check if threads API is available for a discussion\n * \n * @param {Discussion} discussion - The discussion to check\n * @returns {boolean} - True if threads API should be used\n */\nexport function shouldUseThreadsApi(discussion) {\n  // For now, always try to use the threads API\n  // In the future, this could be configurable or based on discussion settings\n  return true;\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts threading information that was added by loadDiscussionThreads\n * \n * @param {Post} post - The post to get metadata for\n * @returns {Object|null} - Thread metadata or null if not available\n */\nexport function getPostThreadMetadata(post) {\n  if (!post || typeof post._threadDepth === 'undefined') {\n    return null;\n  }\n  \n  return {\n    depth: post._threadDepth,\n    threadPath: post._threadPath,\n    isRoot: post._isRoot,\n    childCount: post._childCount,\n    descendantCount: post._descendantCount,\n    rootPostId: post._rootPostId\n  };\n}\n\n/**\n * Check if a post has threading metadata\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post has threading metadata\n */\nexport function hasThreadMetadata(post) {\n  return post && typeof post._threadDepth !== 'undefined';\n} ","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/ReplyComposer'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/PostStream'];","/**\n * Thread Tree Utilities\n * \n * Handles building and flattening thread tree structures from Flarum posts.\n * This module is responsible for:\n * - Building hierarchical thread structures from flat post arrays\n * - Flattening thread trees back to linear arrays in threaded order\n * - Maintaining parent-child relationships between posts\n * \n * @author Threadify Extension\n */\n\n/**\n * Build a threaded tree structure from posts\n * \n * Takes a flat array of posts and organizes them into a hierarchical tree\n * structure based on their parent_id attributes. Posts without a parent_id\n * become root posts, while posts with parent_id become children of their\n * respective parents.\n * \n * @param {Post[]} posts - All posts in the discussion\n * @returns {Post[]} - Array of root posts with _threadChildren attached\n */\nexport function buildThreadTree(posts) {\n  const tree = [];\n  const postMap = new Map();\n  const childrenMap = new Map();\n  \n  // First pass: create post map and initialize children arrays\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    postMap.set(postId, post);\n    childrenMap.set(postId, []);\n  });\n  \n  // Second pass: organize posts by parent-child relationships\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    const parentId = post.attribute('parent_id');\n    \n    if (parentId && postMap.has(String(parentId))) {\n      // This post has a parent, add it to parent's children\n      childrenMap.get(String(parentId)).push(post);\n    } else {\n      // This is a root post (no parent or parent not found)\n      tree.push(post);\n    }\n  });\n  \n  // Third pass: attach children to posts for easy access\n  posts.forEach(post => {\n    if (!post) return;\n    post._threadChildren = childrenMap.get(post.id()) || [];\n  });\n  \n  return tree;\n}\n\n/**\n * Flatten thread tree back to linear array in threaded order\n * \n * Takes a hierarchical tree of posts and flattens it back to a linear array\n * while maintaining the threaded order (parent followed by all its children\n * recursively). This preserves the threading visual structure when posts\n * are rendered linearly.\n * \n * @param {Post[]} rootPosts - Root posts with their children attached via _threadChildren\n * @returns {Post[]} - Flattened array in threaded order\n */\nexport function flattenThreadTree(rootPosts) {\n  const result = [];\n  \n  /**\n   * Recursively add a post and all its children to the result array\n   * @param {Post} post - The post to add\n   * @param {number} depth - Current nesting depth (for potential future use)\n   */\n  function addPostAndChildren(post, depth = 0) {\n    if (!post) return;\n    \n    result.push(post);\n    \n    // Get children and sort them chronologically within each thread level\n    const children = post._threadChildren || [];\n    children.sort((a, b) => {\n      const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n      const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n      return timeA - timeB;\n    });\n    \n    // Recursively add all children\n    children.forEach(child => {\n      addPostAndChildren(child, depth + 1);\n    });\n  }\n  \n  // Sort root posts chronologically to maintain discussion flow\n  rootPosts.sort((a, b) => {\n    const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n    const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n    return timeA - timeB;\n  });\n  \n  // Add each root post and its entire thread branch\n  rootPosts.forEach(rootPost => {\n    addPostAndChildren(rootPost);\n  });\n  \n  return result;\n}\n\n/**\n * Create a threaded post array from flat posts\n * \n * Convenience function that combines buildThreadTree and flattenThreadTree\n * to convert a flat array of posts directly into threaded order.\n * \n * @param {Post[]} posts - Flat array of posts\n * @returns {Post[]} - Posts reordered in threaded structure\n */\nexport function createThreadedPosts(posts) {\n  const threadTree = buildThreadTree(posts);\n  return flattenThreadTree(threadTree);\n} ","/**\n * Thread Depth Calculator\n * \n * Handles calculating and caching thread depth for posts.\n * Thread depth determines how many levels deep a post is in a thread\n * (0 = root post, 1 = direct reply, 2 = reply to reply, etc.)\n * \n * Uses caching to avoid expensive recalculations and includes cycle detection\n * to prevent infinite loops in case of malformed parent relationships.\n * \n * @author Threadify Extension\n */\n\n// Cache for thread depth calculations to avoid recalculating\nconst threadDepthCache = new Map();\n\n// Maximum allowed thread depth to prevent excessive UI indentation\nconst MAX_THREAD_DEPTH = 10;\n\n/**\n * Calculate the thread depth of a post\n * \n * Determines how many levels deep a post is in the thread hierarchy.\n * Uses caching for performance and includes cycle detection for safety.\n * \n * @param {Post} post - The post to calculate depth for\n * @param {Post[]} allPosts - All posts in the discussion (for parent lookup)\n * @returns {number} - The depth (0 = root, 1 = direct reply, etc.)\n */\nexport function calculateThreadDepth(post, allPosts) {\n  const postId = post.id();\n  \n  // Check cache first for performance\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent_id, this is a root post (depth 0)\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Find the parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    // Parent not found, treat as root\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Cycle detection: if we're calculating depth for a post that's already\n  // in our calculation chain, we have a cycle\n  const visited = new Set();\n  const depth = calculateDepthRecursive(post, allPosts, visited);\n  \n  // Cache and return the calculated depth\n  threadDepthCache.set(postId, depth);\n  return depth;\n}\n\n/**\n * Recursive helper for depth calculation with cycle detection\n * @param {Post} post - Current post\n * @param {Post[]} allPosts - All posts for parent lookup\n * @param {Set} visited - Set of visited post IDs to detect cycles\n * @returns {number} - Calculated depth\n */\nfunction calculateDepthRecursive(post, allPosts, visited) {\n  const postId = post.id();\n  \n  // Cycle detection\n  if (visited.has(postId)) {\n    console.warn(`[Threadify] Cycle detected for post ${postId}`);\n    return 0; // Treat cyclic posts as root to break the cycle\n  }\n  \n  // Check cache\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent, this is root level\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    return 0;\n  }\n  \n  // Find parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    return 0; // Parent not found, treat as root\n  }\n  \n  // Add current post to visited set\n  visited.add(postId);\n  \n  // Recursively calculate parent's depth\n  const parentDepth = calculateDepthRecursive(parentPost, allPosts, visited);\n  const depth = parentDepth + 1;\n  \n  // Remove from visited set (backtrack)\n  visited.delete(postId);\n  \n  // Apply maximum depth limit to prevent excessive UI indentation\n  return Math.min(depth, MAX_THREAD_DEPTH);\n}\n\n/**\n * Clear the thread depth cache\n * \n * Should be called when posts are updated, removed, or when switching discussions\n * to ensure fresh calculations.\n */\nexport function clearThreadDepthCache() {\n  threadDepthCache.clear();\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * Generates appropriate CSS classes for styling threaded posts.\n * \n * @param {Post} post - The post to generate classes for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {string[]} - Array of CSS classes\n */\nexport function getThreadCssClasses(post, allPosts) {\n  const threadDepth = calculateThreadDepth(post, allPosts);\n  const classes = [];\n  \n  if (threadDepth > 0) {\n    classes.push('Post--threaded');\n    classes.push(`Post--thread-depth-${threadDepth}`);\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * @param {Post} post - The post to check\n * @returns {boolean} - True if the post is a root post\n */\nexport function isRootPost(post) {\n  return !post.attribute('parent_id');\n}\n\n/**\n * Check if a post is a direct reply (depth 1)\n * @param {Post} post - The post to check\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if the post is a direct reply\n */\nexport function isDirectReply(post, allPosts) {\n  return calculateThreadDepth(post, allPosts) === 1;\n} ","/**\n * Post Loader Utilities (fixed for Flarum 1.8)\n *\n * 修复点：\n * 1) 统一使用字符串比较 ID，避免 number/string 混用造成的漏判。\n * 2) 兼容 postStream.discussion 与 postStream.stream.discussion。\n * 3) 提供 mergeUniquePostsById 以防重复注入同一帖子。\n */\n\nimport app from 'flarum/forum/app';\n\n/** -------------------- Helpers -------------------- **/\n\nfunction toStrId(x) {\n  return x == null ? '' : String(x);\n}\n\nfunction getDiscussionFrom(postStream) {\n  // 兼容两种拿法\n  return postStream?.discussion || postStream?.stream?.discussion || null;\n}\n\nfunction mergeUniquePostsById(basePosts, extraPosts) {\n  const map = new Map();\n  basePosts.filter(Boolean).forEach((p) => map.set(toStrId(p.id()), p));\n  extraPosts.filter(Boolean).forEach((p) => map.set(toStrId(p.id()), p));\n  return Array.from(map.values());\n}\n\nfunction loadPostsByIds(postIds) {\n  const ids = (postIds || []).map(toStrId).filter(Boolean);\n  if (ids.length === 0) return Promise.resolve([]);\n\n  return app.store.find('posts', {\n    filter: { id: ids.join(',') },\n    // page: { limit: ids.length } // 可选：限制体积\n  });\n}\n\n/** -------------------- Public APIs -------------------- **/\n\n/**\n * 递归补齐“缺失父帖”\n * - 扫描 currentPosts，找出其 parent_id 未在集合中的父帖，批量拉取；\n * - 合并后若仍有更上层父帖缺失，则继续递归，直到根或已齐全。\n */\nexport function loadMissingParentPosts(postStream, currentPosts) {\n  const posts = (currentPosts || []).filter(Boolean);\n  const currentIdSet = new Set(posts.map((p) => toStrId(p.id())));\n  const missingParentIds = [];\n\n  posts.forEach((p) => {\n    const pid = toStrId(p?.attribute?.('parent_id'));\n    if (pid && !currentIdSet.has(pid)) missingParentIds.push(pid);\n  });\n\n  const uniqueMissing = Array.from(new Set(missingParentIds));\n  if (uniqueMissing.length === 0) {\n    return Promise.resolve(posts);\n  }\n\n  return loadPostsByIds(uniqueMissing)\n    .then((loadedParents) => {\n      const merged = mergeUniquePostsById(posts, loadedParents);\n      // 递归，直到没有缺父帖\n      return loadMissingParentPosts(postStream, merged);\n    })\n    .catch((err) => {\n      console.warn('[Threadify] Failed to load parent posts:', err);\n      // 出错时保守返回已有帖子，避免卡住\n      return posts;\n    });\n}\n\n/**\n * 仅“保守”补少量子帖\n * - 按讨论里尚未加载的 postId 取一个小样本（默认 5~10）；\n * - 只把其 parent_id 指向“当前已加载集合”的帖子作为“实际子帖”纳入；\n * - 不递归，避免二次抖动。\n */\nexport function loadMinimalChildren(postStream, currentPosts) {\n  const discussion = getDiscussionFrom(postStream);\n  const posts = (currentPosts || []).filter(Boolean);\n  const currentIdSet = new Set(posts.map((p) => toStrId(p.id())));\n\n  if (!discussion || typeof discussion.postIds !== 'function') {\n    return Promise.resolve(posts);\n  }\n\n  const discussionPostIds = (discussion.postIds() || []).map(toStrId);\n  const unloadedIds = discussionPostIds.filter((id) => id && !currentIdSet.has(id));\n\n  if (unloadedIds.length === 0) {\n    return Promise.resolve(posts);\n  }\n\n  const sampleSize = Math.min(10, unloadedIds.length); // 轻量探测\n  const recentUnloaded = unloadedIds.slice(-sampleSize);\n\n  return loadPostsByIds(recentUnloaded)\n    .then((loadedSample) => {\n      // 只收“父在集合里”的实际子帖\n      const actualChildren = (loadedSample || []).filter((p) => {\n        const pid = toStrId(p?.attribute?.('parent_id'));\n        return pid && currentIdSet.has(pid);\n      });\n\n      if (actualChildren.length === 0) {\n        return posts;\n      }\n      return mergeUniquePostsById(posts, actualChildren);\n    })\n    .catch((err) => {\n      console.warn('[Threadify] Failed to load child posts:', err);\n      return posts;\n    });\n}\n\n/**\n * 检测是否“有理由补上下文”\n * - 目前仅检测是否存在缺失父帖；如需可扩展。\n */\nexport function needsThreadContext(posts) {\n  const arr = (posts || []).filter(Boolean);\n  if (arr.length === 0) return false;\n\n  const idSet = new Set(arr.map((p) => toStrId(p.id())));\n  return arr.some((p) => {\n    const pid = toStrId(p?.attribute?.('parent_id'));\n    return pid && !idSet.has(pid);\n  });\n}\n","/**\n * 轻量顺序预取：/discussions/:id/threads-order\n * 提供：\n *  - prefetchThreadOrder(did) -> Promise<void>\n *  - getOrderIndex(did, postId) -> number|undefined\n *  - getDepthPrefetched(did, postId) / getParentPrefetched(did, postId)\n *  - isPrefetched(did) -> boolean\n *  - collectChildrenIdsForParents(did, parentIds, limitPerParent=8, pick='latest', maxTotal=40)\n *\n * 行为：\n *  - 预取成功后触发：window.dispatchEvent(new CustomEvent('threadify:orderReady', { detail:Number(did) }))\n *  - 失败也将 ready 置为 true（空映射），避免重复打爆接口\n */\n\nimport app from 'flarum/forum/app';\n\nconst _cache = new Map(); // did -> { map: Map<postId, {order, depth, parentId}>, ready: Promise|true }\n\nexport function prefetchThreadOrder(discussionId) {\n  const did = String(discussionId);\n  const existing = _cache.get(did);\n  if (existing?.ready === true) return Promise.resolve();\n  if (existing?.ready && typeof existing.ready.then === 'function') return existing.ready;\n\n  const entry = { map: new Map(), ready: null };\n  _cache.set(did, entry);\n\n  entry.ready = app\n    .request({\n      method: 'GET',\n      url: `${app.forum.attribute('apiUrl')}/discussions/${encodeURIComponent(did)}/threads-order`,\n    })\n    .then((res) => {\n      const map = new Map();\n      const list = Array.isArray(res?.order) ? res.order : [];\n      for (const item of list) {\n        if (!item) continue;\n        const pid = Number(item.postId);\n        const ord = Number(item.order);\n        const dep = Number(item.depth);\n        const parent = item.parentPostId != null ? Number(item.parentPostId) : null;\n        if (!Number.isNaN(pid) && !Number.isNaN(ord)) {\n          map.set(pid, {\n            order: ord,\n            depth: Number.isNaN(dep) ? 0 : dep,\n            parentId: parent,\n          });\n        }\n      }\n      entry.map = map;\n      entry.ready = true;\n\n      try { window.dispatchEvent(new CustomEvent('threadify:orderReady', { detail: Number(did) })); } catch {}\n      try { setTimeout(() => m.redraw(), 0); } catch {}\n    })\n    .catch((e) => {\n      console.warn('[Threadify] order prefetch failed:', e);\n      entry.ready = true; // 标记完成以免风暴；map 为空，排序自然回退到本地线程顺序\n    });\n\n  return entry.ready;\n}\n\nexport function getOrderIndex(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry?.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.order : undefined;\n}\n\nexport function getDepthPrefetched(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry?.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.depth : undefined;\n}\n\nexport function getParentPrefetched(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry?.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.parentId : undefined;\n}\n\nexport function isPrefetched(discussionId) {\n  const entry = _cache.get(String(discussionId));\n  return !!(entry && entry.ready === true);\n}\n\n/**\n * 从预取映射中为一组父帖收集子帖 ID（按 order 排序）\n * @param {number|string} discussionId\n * @param {Iterable<number|string>} parentIds\n * @param {number} limitPerParent 每个父帖最多取多少子帖\n * @param {'latest'|'earliest'} pick 选最新还是最早的子帖\n * @param {number} maxTotal 本次最多返回多少条，防止一次性过大\n * @returns {number[]} 子帖 ID（去重后）\n */\nexport function collectChildrenIdsForParents(discussionId, parentIds, limitPerParent = 8, pick = 'latest', maxTotal = 40) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry?.map || !parentIds) return [];\n\n  const pset = new Set([...parentIds].map((x) => Number(x)));\n  if (pset.size === 0) return [];\n\n  // 先把所有候选子帖取出来：Map<parentId, Array<{postId, order}>>\n  const buckets = new Map();\n  for (const [postId, rec] of entry.map.entries()) {\n    const pid = rec?.parentId;\n    if (!pid || !pset.has(pid)) continue;\n    let arr = buckets.get(pid);\n    if (!arr) { arr = []; buckets.set(pid, arr); }\n    arr.push({ postId: Number(postId), order: rec.order || 0 });\n  }\n\n  // 对每个父帖的孩子按 order 排序后截取\n  const out = [];\n  for (const [pid, arr] of buckets.entries()) {\n    arr.sort((a, b) => a.order - b.order);\n    const picked = pick === 'earliest' ? arr.slice(0, limitPerParent) : arr.slice(-limitPerParent);\n    for (const it of picked) out.push(it.postId);\n    if (out.length >= maxTotal) break;\n  }\n\n  // 去重裁剪\n  return Array.from(new Set(out)).slice(0, maxTotal);\n}\n","/**\n * Threaded PostStream Component (stable + prefetch + ancestor & children completion)\n *\n * 特性：\n * - 首帧不阻断：首次渲染仍走 Flarum 原序；\n * - 预取全局顺序：/threads-order；\n * - 依据预取映射「向上补齐缺失祖先（最多 N 层）」再「按需补齐子帖（每父帖最多 M 条，整体上限 K）」；\n * - 不改写 visiblePosts（避免 anchorScroll 报错）；\n * - 仅当 PostStream 空闲时重排；\n * - 预取不可用则回退到“补父 + 少量子 + 简易线程化（ThreadTree）”。\n */\n\nimport app from 'flarum/forum/app';\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\n\nimport { createThreadedPosts } from '../utils/ThreadTree';\nimport { clearThreadDepthCache } from '../utils/ThreadDepth';\nimport { loadMissingParentPosts, loadMinimalChildren } from '../utils/PostLoader';\nimport {\n  prefetchThreadOrder,\n  getOrderIndex,\n  getParentPrefetched,\n  isPrefetched,\n  collectChildrenIdsForParents,\n} from '../utils/ThreadOrderPrefetch';\n\n// ---- 配置 -----------------------------------------------------------\nconst MAX_ANCESTOR_STEPS = 3;        // 追溯祖先层数上限\nconst CHILD_LIMIT_PER_PARENT = 8;    // 每个父帖最多补多少子帖\nconst CHILD_MAX_TOTAL = 40;          // 本次最多补多少子帖\nconst ENABLE_MINIMAL_CHILD_LOADING = true; // 预取缺失时的后备策略\n\n// ---- 模块级状态 ----------------------------------------------------\nlet isReordering = false;\nlet reorderedPostsCache = null;\nlet lastPostCount = 0;\nlet originalPostsMethod = null;\nlet currentDiscussionId = null;\n\n// ---- 工具：判定流是否忙碌（翻页/锚点附近加载等） --------------------\nfunction streamBusy(state) {\n  if (!state) return false;\n  return !!(\n    state.loading ||\n    state.loadingPrevious ||\n    state.loadingNext ||\n    state.loadingNear ||\n    state._loadingPrevious ||\n    state._loadingNext\n  );\n}\n\n// ===================================================================\n// 初始化\n// ===================================================================\nexport function initThreadedPostStream() {\n  extend(PostStream.prototype, 'oninit', function () {\n    const did = this.stream.discussion && this.stream.discussion.id && this.stream.discussion.id();\n    if (currentDiscussionId !== did) resetState(did);\n\n    if (!originalPostsMethod) originalPostsMethod = this.stream.posts;\n\n    if (did) prefetchThreadOrder(did);\n\n    this.stream.posts = () => {\n      if (reorderedPostsCache) return reorderedPostsCache;\n\n      const original = originalPostsMethod.call(this.stream) || [];\n      if (!isReordering && original.filter(Boolean).length > 0) {\n        buildCacheWithPrefetch(this);\n      }\n      return original;\n    };\n\n    const cur = originalPostsMethod.call(this.stream) || [];\n    lastPostCount = cur.filter(Boolean).length;\n    if (lastPostCount > 0) buildCacheWithPrefetch(this);\n  });\n\n  extend(PostStream.prototype, 'onupdate', function () {\n    if (!originalPostsMethod) return;\n\n    const current = originalPostsMethod.call(this.stream) || [];\n    const count = current.filter(Boolean).length;\n\n    if (count !== lastPostCount) {\n      lastPostCount = count;\n      reorderedPostsCache = null;\n      clearThreadDepthCache();\n\n      if (!streamBusy(this.stream)) {\n        buildCacheWithPrefetch(this);\n      } else {\n        setTimeout(() => {\n          if (!streamBusy(this.stream)) buildCacheWithPrefetch(this);\n        }, 60);\n      }\n    }\n  });\n\n  // 预取就绪时尝试重建（避免同帧与 anchorScroll 打架）\n  window.addEventListener('threadify:orderReady', (ev) => {\n    const did = ev?.detail;\n    if (!did || did !== currentDiscussionId) return;\n    setTimeout(() => {\n      try {\n        if (!isReordering && !reorderedPostsCache) buildCacheWithPrefetch(this);\n      } catch {}\n    }, 0);\n  });\n}\n\n// ===================================================================\n// 核心：预取顺序 + 祖先补齐 + 子帖补齐 -> 稳定重排\n// ===================================================================\nfunction buildCacheWithPrefetch(postStream) {\n  if (isReordering) return;\n  isReordering = true;\n\n  const finish = (arr) => {\n    reorderedPostsCache = arr;\n    isReordering = false;\n    setTimeout(() => { try { m.redraw(); } catch {} }, 0);\n  };\n\n  try {\n    if (!originalPostsMethod) return finish(null);\n\n    const originalPosts = originalPostsMethod.call(postStream.stream) || [];\n    const validPosts = originalPosts.filter(Boolean);\n    if (validPosts.length === 0) return finish(null);\n\n    const did = postStream.stream.discussion && postStream.stream.discussion.id && postStream.stream.discussion.id();\n\n    const build = () =>\n      ensureAncestorsByPrefetch(did, validPosts)\n        .then((withAncestors) => ensureChildrenByPrefetch(did, withAncestors))\n        .then((ready) => {\n          const sorted = sortByPrefetchOrder(did, ready);\n          if (sorted && sorted.length) {\n            const threadedArray = padNullsToLength(sorted, originalPosts.length);\n            finish(threadedArray);\n            return;\n          }\n\n          // —— 预取不可用或无映射命中：回退 —— //\n          ensureParentsLoaded(postStream, validPosts)\n            .then((postsWithParents) =>\n              ENABLE_MINIMAL_CHILD_LOADING\n                ? ensureMinimalChildren(postStream, postsWithParents)\n                : postsWithParents\n            )\n            .then((postsReady) => {\n              const threaded = createThreadedPosts(postsReady);\n              const threadedArray = padNullsToLength(threaded, originalPosts.length);\n              finish(threadedArray);\n            })\n            .catch((err) => {\n              console.warn('[Threadify] prefetch & fallback threading both failed:', err);\n              finish(null);\n            });\n        });\n\n    if (did && !isPrefetched(did)) {\n      prefetchThreadOrder(did).finally(build);\n    } else {\n      build();\n    }\n  } catch (e) {\n    console.error('[Threadify] buildCacheWithPrefetch failed:', e);\n    isReordering = false;\n  }\n}\n\n// —— 祖先补齐（最多 MAX_ANCESTOR_STEPS 层） ——\nfunction ensureAncestorsByPrefetch(discussionId, posts) {\n  return new Promise((resolve) => {\n    if (!discussionId || !Array.isArray(posts) || posts.length === 0) return resolve(posts);\n\n    const loaded = new Set(posts.map((p) => String(p.id && p.id())));\n    const toFetch = new Set();\n\n    for (const p of posts) {\n      let step = 0;\n      let cur = p && p.id && Number(p.id());\n      while (cur && step < MAX_ANCESTOR_STEPS) {\n        const parent = getParentPrefetched(discussionId, cur);\n        if (!parent) break;\n        if (!loaded.has(String(parent))) toFetch.add(String(parent));\n        cur = parent;\n        step++;\n      }\n    }\n\n    if (toFetch.size === 0) return resolve(posts);\n\n    app.store\n      .find('posts', { filter: { id: Array.from(toFetch).join(',') } })\n      .then((loadedParents) => {\n        const map = new Map(posts.map((p) => [String(p.id && p.id()), p]));\n        for (const lp of loadedParents || []) {\n          const id = String(lp.id && lp.id());\n          if (!map.has(id)) map.set(id, lp);\n        }\n        resolve(Array.from(map.values()));\n      })\n      .catch(() => resolve(posts));\n  });\n}\n\n// —— 子帖补齐（依据预取映射为当前已加载的父帖拉取若干“远在后面的子帖”） ——\nfunction ensureChildrenByPrefetch(discussionId, posts) {\n  return new Promise((resolve) => {\n    if (!discussionId || !Array.isArray(posts) || posts.length === 0) return resolve(posts);\n\n    const loadedIds = new Set(posts.map((p) => String(p.id && p.id())));\n    const parentIds = new Set(posts.map((p) => p && p.id && Number(p.id())));\n\n    const childrenIds = collectChildrenIdsForParents(\n      discussionId,\n      parentIds,\n      CHILD_LIMIT_PER_PARENT,\n      'latest',\n      CHILD_MAX_TOTAL\n    );\n\n    // 过滤掉已加载的\n    const toFetch = childrenIds.filter((id) => !loadedIds.has(String(id)));\n    if (toFetch.length === 0) return resolve(posts);\n\n    app.store\n      .find('posts', { filter: { id: toFetch.join(',') } })\n      .then((loadedChildren) => resolve([...posts, ...(loadedChildren || [])]))\n      .catch(() => resolve(posts));\n  });\n}\n\n// —— 用预取顺序排序（只重排“已加载的帖子”） ——\nfunction sortByPrefetchOrder(discussionId, posts) {\n  if (!discussionId || !Array.isArray(posts) || posts.length === 0) return null;\n  const hit = posts.some((p) => getOrderIndex(discussionId, p.id && p.id()) != null);\n  if (!hit) return null;\n\n  const list = posts.slice();\n  list.sort((a, b) => {\n    const aid = a && a.id && a.id();\n    const bid = b && b.id && b.id();\n    const ao = getOrderIndex(discussionId, aid);\n    const bo = getOrderIndex(discussionId, bid);\n\n    if (ao != null || bo != null) {\n      if (ao == null && bo == null) return 0;\n      if (ao == null) return 1;\n      if (bo == null) return -1;\n      if (ao !== bo) return ao - bo;\n    }\n    return 0; // 稳定排序：都没有映射则保持相对顺序\n  });\n\n  return list;\n}\n\n// —— 维持原数组长度（分页位）——不足用 null 填充 ——\nfunction padNullsToLength(arr, targetLen) {\n  const result = Array.isArray(arr) ? arr.slice() : [];\n  const need = Math.max(0, targetLen - result.length);\n  for (let i = 0; i < need; i++) result.push(null);\n  return result;\n}\n\n// ---- 后备加载（无预取时） ------------------------------------------\nfunction ensureParentsLoaded(postStream, posts) {\n  if (typeof loadMissingParentPosts === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMissingParentPosts(ctx, posts).catch(() => fallbackLoadParents(posts));\n  }\n  return fallbackLoadParents(posts);\n}\n\nfunction ensureMinimalChildren(postStream, posts) {\n  if (typeof loadMinimalChildren === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMinimalChildren(ctx, posts).catch(() => posts);\n  }\n  return Promise.resolve(posts);\n}\n\nfunction fallbackLoadParents(currentPosts) {\n  const byId = new Map(currentPosts.filter(Boolean).map((p) => [String(p.id()), p]));\n  const missing = [];\n  currentPosts.forEach((p) => {\n    const pid = p && p.attribute ? p.attribute('parent_id') : null;\n    if (pid && !byId.has(String(pid))) missing.push(String(pid));\n  });\n  if (missing.length === 0) return Promise.resolve(currentPosts);\n\n  return app.store\n    .find('posts', { filter: { id: missing.join(',') } })\n    .then((loaded) => fallbackLoadParents([...currentPosts, ...loaded]))\n    .catch(() => currentPosts);\n}\n\n// ---- 导出工具 ------------------------------------------------------\nexport function getThreadedPostsCache() { return reorderedPostsCache; }\n\nexport function forceRebuildCache(postStream) {\n  reorderedPostsCache = null;\n  clearThreadDepthCache();\n  if (!streamBusy(postStream && postStream.stream)) buildCacheWithPrefetch(postStream);\n}\n\nexport function isThreadingActive() { return !!(reorderedPostsCache && originalPostsMethod); }\n\nexport function getThreadingStats() {\n  return {\n    hasCachedPosts: !!reorderedPostsCache,\n    cachedPostCount: reorderedPostsCache ? reorderedPostsCache.filter(Boolean).length : 0,\n    isReordering,\n    lastPostCount,\n    hasOriginalMethod: !!originalPostsMethod,\n    discussionId: currentDiscussionId,\n  };\n}\n\nfunction resetState(discussionId) {\n  currentDiscussionId = discussionId;\n  isReordering = false;\n  reorderedPostsCache = null;\n  lastPostCount = 0;\n  originalPostsMethod = null;\n  clearThreadDepthCache();\n}\n","import app from 'flarum/forum/app';\nimport { extend } from 'flarum/common/extend';\n\nimport DiscussionPage from 'flarum/forum/components/DiscussionPage';\nimport DiscussionListItem from 'flarum/forum/components/DiscussionListItem';\n\nimport { initThreadedPost } from './components/ThreadedPost';\nimport { initThreadedReplyComposer } from './components/ThreadedReplyComposer';\nimport { initThreadedPostStream } from './components/ThreadedPostStream';\nimport { prefetchThreadOrder } from './utils/ThreadOrderPrefetch';\n\napp.initializers.add('syntaxoutlaw-threadify', () => {\n  initThreadedPost();\n  initThreadedReplyComposer();\n  initThreadedPostStream();\n\n  // 进入讨论页即预取\n  extend(DiscussionPage.prototype, 'oninit', function () {\n    const did = this.discussion && this.discussion.id && this.discussion.id();\n    if (did) prefetchThreadOrder(did);\n  });\n\n  // 讨论列表项：首次鼠标悬停 / 触摸即预取，提升命中率\n  extend(DiscussionListItem.prototype, 'oncreate', function () {\n    const discussion = this.attrs.discussion;\n    if (!discussion) return;\n    const did = discussion.id();\n    const handler = () => prefetchThreadOrder(did);\n    // 只触发一次即可\n    this.element && this.element.addEventListener('mouseenter', handler, { once: true });\n    this.element && this.element.addEventListener('touchstart', handler, { once: true, passive: true });\n  });\n});\n","/**\n * Threaded Post Component Extensions\n * \n * Handles Post component extensions for threading functionality.\n * This module is responsible for:\n * - Adding threading CSS classes to posts based on their depth\n * - Managing post-specific threading visual elements\n * - Integrating with the ThreadDepth utility for depth calculations\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport Post from 'flarum/forum/components/Post';\nimport { getThreadCssClasses } from '../utils/SimplifiedThreadDepth';\n\n/**\n * Initialize Post component extensions for threading\n * \n * Sets up all the necessary hooks and extensions for the Post component\n * to display threading information properly.\n */\nexport function initThreadedPost() {\n  // Hook into Post component to add threading CSS classes\n  extend(Post.prototype, 'classes', function(classes) {\n    const post = this.attrs.post;\n    \n    // Skip processing if we don't have a valid post\n    if (!post) {\n      console.warn('[Threadify] No post in ThreadedPost.classes');\n      return classes;\n    }\n    \n    // Get threading CSS classes from simplified utility\n    const threadClasses = getThreadCssClasses(post);\n    console.log(`[Threadify] Adding classes to post ${post.id()}: ${threadClasses.join(', ')}`);\n    \n    threadClasses.forEach(className => {\n      classes.push(className);\n    });\n    \n    return classes;\n  });\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts useful threading metadata from a post that can be used\n * by other components or for debugging purposes.\n * \n * @param {Post} post - The post to extract metadata from\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Object} - Thread metadata object\n */\nexport function getPostThreadMetadata(post, allPosts) {\n  if (!post) return null;\n  \n  const parentId = post.attribute('parent_id');\n  const parentPost = parentId ? allPosts.find(p => p && p.id() == parentId) : null;\n  \n  // Find direct children of this post\n  const children = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  // Calculate some thread statistics\n  const descendants = getDescendantCount(post, allPosts);\n  \n  return {\n    postId: post.id(),\n    parentId: parentId,\n    hasParent: !!parentPost,\n    parentPost: parentPost,\n    directChildren: children,\n    childrenCount: children.length,\n    descendantCount: descendants,\n    isRootPost: !parentId,\n    threadClasses: getThreadCssClasses(post, allPosts)\n  };\n}\n\n/**\n * Count all descendants (children, grandchildren, etc.) of a post\n * \n * @param {Post} post - The post to count descendants for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {number} - Total number of descendants\n */\nfunction getDescendantCount(post, allPosts) {\n  const directChildren = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  let count = directChildren.length;\n  \n  // Recursively count descendants of each child\n  directChildren.forEach(child => {\n    count += getDescendantCount(child, allPosts);\n  });\n  \n  return count;\n}\n\n/**\n * Check if a post is part of a specific thread branch\n * \n * Determines if a post is either a descendant or ancestor of another post.\n * Useful for highlighting related posts or collapsing thread branches.\n * \n * @param {Post} post1 - First post\n * @param {Post} post2 - Second post  \n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if posts are in the same thread branch\n */\nexport function arePostsInSameBranch(post1, post2, allPosts) {\n  if (!post1 || !post2 || post1.id() === post2.id()) {\n    return false;\n  }\n  \n  // Check if post1 is an ancestor of post2\n  let currentPost = post2;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post1.id()) {\n      return true; // post1 is an ancestor of post2\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  // Check if post2 is an ancestor of post1\n  currentPost = post1;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post2.id()) {\n      return true; // post2 is an ancestor of post1\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  return false;\n}\n\n/**\n * Get the root post of a thread branch\n * \n * Traces back through parent relationships to find the root post\n * of the thread branch that contains the given post.\n * \n * @param {Post} post - The post to find the root for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Post|null} - The root post of the thread branch\n */\nexport function getThreadRoot(post, allPosts) {\n  if (!post) return null;\n  \n  let currentPost = post;\n  let rootPost = post;\n  \n  // Trace back through parents until we find a post with no parent\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) {\n      rootPost = currentPost;\n      break;\n    }\n    \n    const parentPost = allPosts.find(p => p && p.id() == parentId);\n    if (!parentPost) {\n      // Parent not found, current post becomes the effective root\n      rootPost = currentPost;\n      break;\n    }\n    \n    rootPost = parentPost;\n    currentPost = parentPost;\n  }\n  \n  return rootPost;\n} \n","/**\n * Simplified Thread Depth Utilities\n * \n * This replaces the complex ThreadDepth calculation logic with simple\n * utilities that use pre-computed thread depths from the threads API.\n * \n * Benefits:\n * - No expensive depth calculations on frontend\n * - No caching needed - depth is already computed\n * - More reliable since depth is calculated once on backend\n * - Simpler code with fewer edge cases\n * \n * @author Threadify Extension\n */\n\nimport { getPostThreadMetadata } from './ThreadsApi';\n\n// Maximum allowed thread depth for UI display\nconst MAX_DISPLAY_DEPTH = 10;\n\n/**\n * Get thread depth for a post\n * \n * Uses pre-computed depth from threads API metadata instead of calculating.\n * \n * @param {Post} post - The post to get depth for\n * @returns {number} - The thread depth (0 = root, 1 = reply, etc.)\n */\nexport function getThreadDepth(post) {\n  if (!post) {\n    return 0;\n  }\n  \n  // Check if post has threading metadata from threads API\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return Math.min(metadata.depth, MAX_DISPLAY_DEPTH);\n  }\n  \n  // Fallback: use old parent_id attribute if available\n  const parentId = post.attribute('parent_id');\n  if (parentId) {\n    // Simple fallback - assume depth 1 for any post with parent\n    // This is not as accurate but prevents complete failure\n    return 1;\n  }\n  \n  // No threading information available, treat as root\n  return 0;\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * @param {Post} post - The post to get CSS classes for\n * @returns {string[]} - Array of CSS class names\n */\nexport function getThreadCssClasses(post) {\n  const depth = getThreadDepth(post);\n  const classes = [];\n  \n  if (depth > 0) {\n    classes.push('threaded-post');\n    classes.push(`thread-depth-${depth}`);\n    \n    // Add general depth classes for easier styling\n    if (depth >= 3) {\n      classes.push('thread-deep');\n    }\n    if (depth >= 5) {\n      classes.push('thread-very-deep');\n    }\n  } else {\n    classes.push('thread-root');\n  }\n  \n  // Add metadata-based classes if available\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    if (metadata.isRoot) {\n      classes.push('thread-root-confirmed');\n    }\n    if (metadata.childCount > 0) {\n      classes.push('has-children');\n      classes.push(`child-count-${Math.min(metadata.childCount, 10)}`);\n    }\n    if (metadata.descendantCount > 0) {\n      classes.push('has-descendants');\n    }\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post is a root post\n */\nexport function isRootPost(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.isRoot;\n  }\n  \n  // Fallback: check if post has no parent_id\n  return !post.attribute('parent_id');\n}\n\n/**\n * Get thread root ID for a post\n * \n * @param {Post} post - The post to get root for\n * @returns {string|null} - Root post ID or null if not available\n */\nexport function getThreadRootId(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.rootPostId;\n  }\n  \n  // Fallback: if no metadata, assume the post itself is root if no parent\n  if (!post.attribute('parent_id')) {\n    return post.id();\n  }\n  \n  return null;\n}\n\n/**\n * Get child count for a post\n * \n * @param {Post} post - The post to get child count for\n * @returns {number} - Number of direct children\n */\nexport function getChildCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.childCount : 0;\n}\n\n/**\n * Get descendant count for a post\n * \n * @param {Post} post - The post to get descendant count for\n * @returns {number} - Total number of descendants (children + grandchildren + ...)\n */\nexport function getDescendantCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.descendantCount : 0;\n}\n\n/**\n * Get thread path for a post\n * \n * @param {Post} post - The post to get thread path for\n * @returns {string|null} - Thread path (e.g., \"1/5/12\") or null if not available\n */\nexport function getThreadPath(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.threadPath : null;\n} ","/**\n * Threaded Reply Composer Extensions\n * \n * Handles ReplyComposer component extensions for threading functionality.\n * This module is responsible for:\n * - Extracting parent_id from post mentions in reply content\n * - Adding parent_id to the reply data before submission\n * - Integrating with Flarum's mentions extension for seamless threading\n * \n * The threading system works by detecting post mentions in the format:\n * @\"Display Name\"#p123 where 123 is the post ID that becomes the parent_id\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport ReplyComposer from 'flarum/forum/components/ReplyComposer';\n\n/**\n * Initialize ReplyComposer component extensions for threading\n * \n * Sets up hooks to automatically detect and add parent_id relationships\n * when users reply to specific posts using the mentions system.\n */\nexport function initThreadedReplyComposer() {\n  // Hook into reply submission to add parent_id\n  extend(ReplyComposer.prototype, 'data', function(data) {\n    const parentId = extractParentIdFromContent(data.content);\n    \n    if (parentId) {\n      // Add parent_id directly to the data object\n      data.parent_id = parentId;\n      console.log('[Threadify] Reply threading to post', parentId);\n    }\n    \n    return data;\n  });\n}\n\n/**\n * Extract parent post ID from reply content\n * \n * Parses the reply content for post mentions from the mentions extension\n * and extracts the post ID to use as parent_id for threading.\n * \n * Supported mention formats:\n * - @\"Display Name\"#p123 (standard post mention)\n * - Multiple mentions (uses the first one found)\n * \n * @param {string} content - The reply content to parse\n * @returns {number|null} - The parent post ID or null if none found\n */\nexport function extractParentIdFromContent(content) {\n  if (!content || typeof content !== 'string') {\n    return null;\n  }\n  \n  // Parse the content for post mentions from the mentions extension\n  // Format: @\"Display Name\"#p123 where 123 is the post ID\n  const postMentionMatch = content.match(/@\"[^\"]*\"#p(\\d+)/);\n  \n  if (postMentionMatch && postMentionMatch[1]) {\n    const parentId = parseInt(postMentionMatch[1], 10);\n    \n    // Validate that it's a valid number\n    if (!isNaN(parentId) && parentId > 0) {\n      return parentId;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract all mentioned post IDs from content\n * \n * Gets all post mentions from the content, not just the first one.\n * Useful for analytics or advanced threading features.\n * \n * @param {string} content - The reply content to parse\n * @returns {number[]} - Array of mentioned post IDs\n */\nexport function extractAllMentionedPostIds(content) {\n  if (!content || typeof content !== 'string') {\n    return [];\n  }\n  \n  const postMentionRegex = /@\"[^\"]*\"#p(\\d+)/g;\n  const matches = [];\n  let match;\n  \n  while ((match = postMentionRegex.exec(content)) !== null) {\n    const postId = parseInt(match[1], 10);\n    if (!isNaN(postId) && postId > 0) {\n      matches.push(postId);\n    }\n  }\n  \n  return matches;\n}\n\n/**\n * Check if content contains post mentions\n * \n * @param {string} content - The content to check\n * @returns {boolean} - True if content contains post mentions\n */\nexport function hasPostMentions(content) {\n  return extractParentIdFromContent(content) !== null;\n}\n\n/**\n * Get threading context from reply content\n * \n * Extracts comprehensive threading information from reply content,\n * including the primary parent and any additional mentioned posts.\n * \n * @param {string} content - The reply content to analyze\n * @returns {Object} - Threading context object\n */\nexport function getThreadingContext(content) {\n  const primaryParentId = extractParentIdFromContent(content);\n  const allMentionedIds = extractAllMentionedPostIds(content);\n  \n  return {\n    primaryParentId: primaryParentId,\n    allMentionedPostIds: allMentionedIds,\n    hasMentions: allMentionedIds.length > 0,\n    mentionCount: allMentionedIds.length,\n    isThreadedReply: primaryParentId !== null\n  };\n}\n\n/**\n * Validate threading data before submission\n * \n * Performs validation on the threading data to ensure it's valid\n * before the reply is submitted to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Validation result with isValid boolean and any error messages\n */\nexport function validateThreadingData(data) {\n  const result = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check if parent_id is present and valid\n  if (data.parent_id !== undefined) {\n    if (typeof data.parent_id !== 'number' || data.parent_id <= 0) {\n      result.isValid = false;\n      result.errors.push('Invalid parent_id: must be a positive number');\n    }\n  }\n  \n  // Check for potential threading issues\n  if (data.content && hasPostMentions(data.content)) {\n    const context = getThreadingContext(data.content);\n    \n    if (!data.parent_id && context.isThreadedReply) {\n      result.warnings.push('Content contains post mentions but no parent_id was set');\n    }\n    \n    if (context.mentionCount > 1) {\n      result.warnings.push(`Multiple post mentions found (${context.mentionCount}), only first will be used for threading`);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Clean threading data for submission\n * \n * Ensures threading data is properly formatted and cleaned before\n * being sent to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Cleaned data object\n */\nexport function cleanThreadingData(data) {\n  const cleanedData = { ...data };\n  \n  // Ensure parent_id is a proper integer or remove it\n  if (cleanedData.parent_id !== undefined) {\n    const parentId = parseInt(cleanedData.parent_id, 10);\n    if (!isNaN(parentId) && parentId > 0) {\n      cleanedData.parent_id = parentId;\n    } else {\n      delete cleanedData.parent_id;\n    }\n  }\n  \n  return cleanedData;\n} "],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","flarum","core","compat","getPostThreadMetadata","post","_threadDepth","depth","threadPath","_threadPath","isRoot","_isRoot","childCount","_childCount","descendantCount","_descendantCount","rootPostId","_rootPostId","flattenThreadTree","rootPosts","result","addPostAndChildren","push","children","_threadChildren","sort","b","createdAt","getTime","forEach","child","rootPost","threadDepthCache","Map","clearThreadDepthCache","clear","toStrId","x","String","mergeUniquePostsById","basePosts","extraPosts","map","filter","Boolean","p","set","id","Array","from","values","loadPostsByIds","postIds","ids","length","Promise","resolve","app","find","join","loadMissingParentPosts","postStream","currentPosts","posts","currentIdSet","Set","missingParentIds","pid","attribute","has","uniqueMissing","then","loadedParents","merged","err","console","warn","_cache","prefetchThreadOrder","discussionId","did","existing","ready","entry","method","url","encodeURIComponent","res","_step","_iterator","_createForOfIteratorHelperLoose","isArray","order","done","item","value","Number","postId","ord","dep","parent","parentPostId","isNaN","parentId","window","dispatchEvent","CustomEvent","detail","_unused","setTimeout","m","redraw","_unused2","e","getOrderIndex","rec","undefined","getParentPrefetched","isReordering","reorderedPostsCache","lastPostCount","originalPostsMethod","currentDiscussionId","streamBusy","state","loading","loadingPrevious","loadingNext","loadingNear","_loadingPrevious","_loadingNext","buildCacheWithPrefetch","finish","arr","originalPosts","stream","validPosts","discussion","build","loaded","toFetch","step","cur","add","size","_step2","_iterator2","lp","withAncestors","loadedIds","parentIds","childrenIds","limitPerParent","pick","maxTotal","pset","concat","buckets","entries","_step2$value","_step3","out","_iterator3","_step3$value","_step4","_iterator4","slice","it","collectChildrenIdsForParents","loadedChildren","ensureChildrenByPrefetch","sorted","some","list","aid","bid","ao","bo","sortByPrefetchOrder","threadedArray","padNullsToLength","fallbackLoadParents","ensureParentsLoaded","postsWithParents","_postStream$stream","getDiscussionFrom","unloadedIds","sampleSize","Math","min","loadedSample","actualChildren","loadMinimalChildren","ensureMinimalChildren","postsReady","threadTree","tree","postMap","childrenMap","buildThreadTree","createThreadedPosts","error","targetLen","need","max","i","byId","missing","extend","Post","classes","this","attrs","threadClasses","metadata","getThreadDepth","getThreadCssClasses","log","className","ReplyComposer","data","content","postMentionMatch","match","parseInt","extractParentIdFromContent","parent_id","_this3","PostStream","_this","original","_this2","count","addEventListener","ev","initThreadedPostStream","DiscussionPage","DiscussionListItem","handler","element","once","passive"],"sourceRoot":""}