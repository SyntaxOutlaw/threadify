{"version":3,"file":"forum.js","mappings":"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","sources":["webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/bootstrap","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/compat get default export","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/define property getters","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/hasOwnProperty shorthand","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/app']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/extend']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/DiscussionPage']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/Post']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadsApi.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadOrderPrefetch.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/SimplifiedThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/ReplyComposer']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/PostStream']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ApiThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/states/PostStreamState']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/NewPostObserver.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/index.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPost.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedReplyComposer.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/app'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/DiscussionPage'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/Post'];","/**\n * threads-order API 轻量层\n * - 负责预取并缓存：Map<postId, { order, depth, parentId }>\n * - 暴露读取与监听工具\n */\n\nconst _cache = new Map(); // did -> { ready: Promise<void>, map: Map<number,{order,depth,parentId}> }\n\nexport function prefetchThreadsOrder(discussionId) {\n  const did = Number(discussionId);\n  if (!did) return Promise.resolve();\n\n  const hit = _cache.get(did);\n  if (hit && hit.ready) return hit.ready;\n\n  const entry = { ready: null, map: new Map() };\n  _cache.set(did, entry);\n\n  entry.ready = app.request({\n    method: 'GET',\n    url: `${app.forum.attribute('apiUrl')}/discussions/${did}/threads-order`,\n  }).then((res) => {\n    const map = new Map();\n    (res.order || []).forEach(({ postId, order, depth, parentPostId }) => {\n      map.set(Number(postId), {\n        order: Number(order),\n        depth: Number.isFinite(depth) ? Number(depth) : 0,\n        parentId: parentPostId ? Number(parentPostId) : null,\n      });\n    });\n    entry.map = map;\n\n    // 通知前端其它模块（可选）\n    try {\n      window.dispatchEvent(new CustomEvent('threadify:order-ready', { detail: { discussionId: did } }));\n    } catch (e) {}\n  }).catch((e) => {\n    console.warn('[Threadify] threads-order prefetch failed', e);\n  });\n\n  return entry.ready;\n}\n\nexport function getOrderRecord(discussionId, postId) {\n  const entry = _cache.get(Number(discussionId));\n  if (!entry) return undefined;\n  return entry.map.get(Number(postId));\n}\n\nexport function getPrefetchedDepth(discussionId, postId) {\n  const rec = getOrderRecord(discussionId, postId);\n  return rec ? rec.depth : undefined;\n}\n\nexport function hasOrderFor(discussionId) {\n  const entry = _cache.get(Number(discussionId));\n  return !!(entry && entry.map && entry.map.size);\n}\n\n// 供 SimplifiedThreadDepth 使用：把预取到的元数据回传给“加类名”逻辑\nexport function getPostThreadMetadata(post) {\n  if (!post) return null;\n  const discussion = post.discussion && post.discussion();\n  const did = discussion && discussion.id && discussion.id();\n  if (!did) return null;\n\n  const rec = getOrderRecord(did, post.id());\n  if (!rec) return null;\n\n  // 注意：rootPostId/descendantCount 这类聚合值由服务端负责；此处仅返回前端需要的 depth/parent\n  return {\n    depth: rec.depth,\n    threadPath: null,\n    isRoot: !rec.parentId,\n    childCount: 0,\n    descendantCount: 0,\n    rootPostId: null,\n  };\n}\n","/**\n * 轻量顺序预取：/discussions/:id/threads-order\n * 提供：\n *  - prefetchThreadOrder(did, { force?: boolean }) -> Promise<void>\n *  - getOrderIndex(did, postId) -> number|undefined\n *  - getDepthPrefetched(did, postId) -> number|undefined\n *  - getParentPrefetched(did, postId) -> number|undefined\n * 并在预取完成后派发 window 事件：'threadify:order-ready'（detail: { discussionId }）\n */\n\nconst _cache = new Map(); // did -> { map: Map<postId, {order, depth, parentId}>, ready: Promise, ts: number }\nconst TTL_MS = 10_000;\n\nexport function prefetchThreadOrder(discussionId, opts = {}) {\n  const did = String(discussionId);\n  const now = Date.now();\n  const entry = _cache.get(did);\n\n  if (!opts.force && entry && entry.ready && (now - (entry.ts || 0) < TTL_MS)) {\n    return entry.ready; // 命中近期缓存\n  }\n\n  const next = entry || { map: new Map(), ready: null, ts: 0 };\n  _cache.set(did, next);\n\n  next.ready = app.request({\n    method: 'GET',\n    url: `${app.forum.attribute('apiUrl')}/discussions/${did}/threads-order?bust=${now}`,\n  }).then((res) => {\n    const map = new Map();\n    (res.order || []).forEach(({ postId, order, depth, parentPostId }) => {\n      map.set(Number(postId), {\n        order: Number(order),\n        depth: Number.isFinite(depth) ? Number(depth) : 0,\n        parentId: parentPostId ? Number(parentPostId) : null,\n      });\n    });\n    next.map = map;\n    next.ts = Date.now();\n\n    // 通知各处“顺序可用”\n    try {\n      window.dispatchEvent(new CustomEvent('threadify:order-ready', { detail: { discussionId: Number(did) } }));\n    } catch {}\n  }).catch((e) => {\n    console.warn('[Threadify] order prefetch failed', e);\n  });\n\n  return next.ready;\n}\n\nexport function getOrderIndex(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry || !entry.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.order : undefined;\n}\n\nexport function getDepthPrefetched(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry || !entry.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.depth : undefined;\n}\n\nexport function getParentPrefetched(discussionId, postId) {\n  const entry = _cache.get(String(discussionId));\n  if (!entry || !entry.map) return undefined;\n  const rec = entry.map.get(Number(postId));\n  return rec ? rec.parentId : undefined;\n}\n","/**\n * Simplified Thread Depth Utilities (fixed)\n *\n * 优先级：\n *  1) /threads-order 预取的 depth\n *  2) /threads 元数据里的 _threadDepth\n *  3) 本地沿 parent_id 向上爬链计算\n *\n * 始终返回 0..MAX_DISPLAY_DEPTH，且不会抛错。\n */\n\nimport { getPostThreadMetadata } from './ThreadsApi';\nimport { getDepthPrefetched, getParentPrefetched } from './ThreadOrderPrefetch';\n\nconst MAX_DISPLAY_DEPTH = 10;\n\n/** ---- helpers ---- */\nfunction clampDepth(n) {\n  const x = Number(n);\n  return Number.isFinite(x) ? Math.max(0, Math.min(MAX_DISPLAY_DEPTH, x)) : 0;\n}\n\nfunction walkDepthByParentChain(post) {\n  // 沿 parent_id 向上爬；即便父帖未加载也能给出“已知最大深度”\n  let depth = 0;\n  let guard = 0;\n  const seen = new Set();\n\n  let current = post;\n  while (current && guard < 100) {\n    const pid = current.attribute ? current.attribute('parent_id') : null;\n    if (!pid) break;\n\n    // 循环保护\n    if (seen.has(pid)) {\n      console.warn('[Threadify] cycle detected while walking parents of', post && post.id && post.id());\n      depth = 0;\n      break;\n    }\n    seen.add(pid);\n\n    depth += 1;\n    // 试着从 store 取父贴，取不到就以当前深度作准（父贴可能尚未加载）\n    const parent = app.store.getById('posts', String(pid));\n    if (!parent) break;\n\n    current = parent;\n    guard++;\n    if (depth >= MAX_DISPLAY_DEPTH) break;\n  }\n  return clampDepth(depth);\n}\n\n/** ---- public API ---- */\n\n/**\n * Get thread depth for a post (0=root)\n */\nexport function getThreadDepth(post) {\n  if (!post || typeof post.id !== 'function') return 0;\n\n  // 1) 预取顺序里的 depth（最快、最稳定）\n  try {\n    const did =\n      (post.discussion && typeof post.discussion === 'function' && post.discussion() && post.discussion().id && post.discussion().id()) ||\n      null;\n    if (did != null) {\n      const d = getDepthPrefetched(did, post.id());\n      if (Number.isInteger(d)) return clampDepth(d);\n    }\n  } catch (_) {\n    // ignore\n  }\n\n  // 2) /threads 元数据（若前端曾调用过 loadDiscussionThreads）\n  try {\n    const md = getPostThreadMetadata(post);\n    if (md && Number.isInteger(md.depth)) return clampDepth(md.depth);\n  } catch (_) {\n    // ignore\n  }\n\n  // 3) 本地按 parent_id 向上爬链\n  return walkDepthByParentChain(post);\n}\n\n/**\n * CSS classes for a post based on its thread depth.\n * 统一使用：threaded-post / thread-root / thread-depth-N / thread-deep / thread-very-deep\n */\nexport function getThreadCssClasses(post) {\n  const depth = getThreadDepth(post);\n  const classes = [];\n\n  if (depth > 0) {\n    classes.push('threaded-post');\n    classes.push(`thread-depth-${depth}`);\n    if (depth >= 3) classes.push('thread-deep');\n    if (depth >= 5) classes.push('thread-very-deep');\n  } else {\n    classes.push('thread-root');\n  }\n\n  // 尽量从预取或元数据补充“根/父”信息（可选）\n  try {\n    const did =\n      (post.discussion && typeof post.discussion === 'function' && post.discussion() && post.discussion().id && post.discussion().id()) ||\n      null;\n    const prefParent = did != null ? getParentPrefetched(did, post.id()) : undefined;\n    const md = getPostThreadMetadata(post);\n\n    const isRoot =\n      (prefParent === null || prefParent === undefined) ?\n        (!post.attribute || !post.attribute('parent_id')) :\n        (prefParent == null);\n\n    if (isRoot) classes.push('thread-root-confirmed');\n\n    // 可根据 md.childCount / md.descendantCount 再加细化类名（没有就跳过）\n    if (md && Number.isInteger(md.childCount) && md.childCount > 0) {\n      classes.push('has-children', `child-count-${Math.min(md.childCount, 10)}`);\n    }\n    if (md && Number.isInteger(md.descendantCount) && md.descendantCount > 0) {\n      classes.push('has-descendants');\n    }\n  } catch (_) {\n    // 忽略补充信息失败\n  }\n\n  return classes;\n}\n\n/** convenience helpers */\nexport function isRootPost(post) {\n  return getThreadDepth(post) === 0;\n}\n\nexport function getThreadRootId(/* post */) {\n  // 若后续需要，可接入预取 map 里的 rootId；当前仅用于样式则不强制实现\n  return null;\n}\n\nexport function getChildCount(post) {\n  const md = getPostThreadMetadata(post);\n  return md && Number.isInteger(md.childCount) ? md.childCount : 0;\n}\n\nexport function getDescendantCount(post) {\n  const md = getPostThreadMetadata(post);\n  return md && Number.isInteger(md.descendantCount) ? md.descendantCount : 0;\n}\n\nexport function getThreadPath(post) {\n  const md = getPostThreadMetadata(post);\n  return md ? md.threadPath || null : null;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/ReplyComposer'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/PostStream'];","/**\n * 基于 threads-order 的 PostStream 重排\n * - 不改动 PostStreamState 的分页逻辑（保留 null 空洞）\n * - 仅对“已加载的连续区段”做线程顺序重排\n * - 发现帖子数量变化 => 重新预取并重排（兼容 Realtime）\n */\n\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport { prefetchThreadsOrder, hasOrderFor, getOrderRecord } from '../utils/ThreadsApi';\n\nlet currentDid = null;\nlet cached = null;         // 上一次重排后的数组（含 null）\nlet lastCount = -1;        // 上一次非空帖子数量\nlet originalGetter = null; // 暂存原始 posts() 读取\n\nexport function installApiThreadedPostStream() {\n  // 记录原始 getter，并包裹返回值\n  extend(PostStream.prototype, 'oninit', function () {\n    if (!originalGetter) originalGetter = this.stream.posts;\n  });\n\n  // 讨论切换时清理缓存并预取\n  extend(PostStream.prototype, 'oncreate', function () {\n    const did = this.stream && this.stream.discussion && this.stream.discussion.id();\n    if (did && did !== currentDid) {\n      currentDid = did;\n      cached = null;\n      lastCount = -1;\n      prefetchThreadsOrder(did);\n    }\n    // 首帧就尝试构建缓存，避免“轻微闪动”\n    buildCacheIfNeeded(this);\n  });\n\n  // 任何更新都尝试重建（含 Realtime 新增）\n  extend(PostStream.prototype, 'onupdate', function () {\n    buildCacheIfNeeded(this);\n  });\n\n  // 最关键：用我们自己的缓存作为 posts() 的返回值\n  extend(PostStream.prototype, 'posts', function (ret) {\n    if (cached && currentDid === (this.stream && this.stream.discussion && this.stream.discussion.id())) {\n      return cached;\n    }\n    // 兜底：还没准备好时返回原始数组\n    return ret();\n  });\n}\n\n/** 内部：在需要时重建缓存 */\nfunction buildCacheIfNeeded(ps) {\n  if (!ps || !originalGetter) return;\n\n  const did = ps.stream && ps.stream.discussion && ps.stream.discussion.id();\n  if (!did) return;\n\n  const raw = originalGetter.call(ps.stream);\n  if (!raw || !raw.length) { cached = raw; return; }\n\n  // 统计当前已加载的帖子数量\n  const loaded = raw.filter((x) => !!x);\n  const loadedCount = loaded.length;\n\n  // 没有顺序数据时，先去预取；等下一轮 update 再用\n  if (!hasOrderFor(did)) {\n    prefetchThreadsOrder(did).finally(() => { /* 触发下一轮 onupdate 即可 */ });\n    cached = raw;\n    lastCount = loadedCount;\n    return;\n  }\n\n  // 数量或讨论变了，或者还没有缓存 => 重排\n  if (!cached || loadedCount !== lastCount) {\n    cached = reorderWithinLoadedSegment(raw, did);\n    lastCount = loadedCount;\n  }\n}\n\n/**\n * 只在“已加载的连续区段”里做重排；保留前后 null 空洞与长度\n */\nfunction reorderWithinLoadedSegment(originalArr, discussionId) {\n  const arr = originalArr.slice();\n\n  // 找到连续区段 [L, R]\n  let L = 0, R = arr.length - 1;\n  while (L < arr.length && !arr[L]) L++;\n  while (R >= 0 && !arr[R]) R--;\n  if (L > R) return arr; // 全是空\n\n  // 取出连续区段的帖子，按 threads-order 的 order 排序\n  const segment = arr.slice(L, R + 1).filter(Boolean);\n\n  segment.sort((a, b) => {\n    const ra = getOrderRecord(discussionId, a.id());\n    const rb = getOrderRecord(discussionId, b.id());\n    const oa = ra ? ra.order : Number.MAX_SAFE_INTEGER;\n    const ob = rb ? rb.order : Number.MAX_SAFE_INTEGER;\n    // 稳定排序：order 相等时按 post id\n    if (oa === ob) return a.id() - b.id();\n    return oa - ob;\n  });\n\n  // 回填：保持两端的 null 不动，只替换中段的非空位\n  const result = arr.slice();\n  let p = 0;\n  for (let i = L; i <= R; i++) {\n    if (result[i]) {\n      result[i] = segment[p++] || result[i];\n    }\n  }\n  return result;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/states/PostStreamState'];","/**\n * Thread Depth Calculator\n * \n * Handles calculating and caching thread depth for posts.\n * Thread depth determines how many levels deep a post is in a thread\n * (0 = root post, 1 = direct reply, 2 = reply to reply, etc.)\n * \n * Uses caching to avoid expensive recalculations and includes cycle detection\n * to prevent infinite loops in case of malformed parent relationships.\n * \n * @author Threadify Extension\n */\n\n// Cache for thread depth calculations to avoid recalculating\nconst threadDepthCache = new Map();\n\n// Maximum allowed thread depth to prevent excessive UI indentation\nconst MAX_THREAD_DEPTH = 10;\n\n/**\n * Calculate the thread depth of a post\n * \n * Determines how many levels deep a post is in the thread hierarchy.\n * Uses caching for performance and includes cycle detection for safety.\n * \n * @param {Post} post - The post to calculate depth for\n * @param {Post[]} allPosts - All posts in the discussion (for parent lookup)\n * @returns {number} - The depth (0 = root, 1 = direct reply, etc.)\n */\nexport function calculateThreadDepth(post, allPosts) {\n  const postId = post.id();\n  \n  // Check cache first for performance\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent_id, this is a root post (depth 0)\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Find the parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    // Parent not found, treat as root\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Cycle detection: if we're calculating depth for a post that's already\n  // in our calculation chain, we have a cycle\n  const visited = new Set();\n  const depth = calculateDepthRecursive(post, allPosts, visited);\n  \n  // Cache and return the calculated depth\n  threadDepthCache.set(postId, depth);\n  return depth;\n}\n\n/**\n * Recursive helper for depth calculation with cycle detection\n * @param {Post} post - Current post\n * @param {Post[]} allPosts - All posts for parent lookup\n * @param {Set} visited - Set of visited post IDs to detect cycles\n * @returns {number} - Calculated depth\n */\nfunction calculateDepthRecursive(post, allPosts, visited) {\n  const postId = post.id();\n  \n  // Cycle detection\n  if (visited.has(postId)) {\n    console.warn(`[Threadify] Cycle detected for post ${postId}`);\n    return 0; // Treat cyclic posts as root to break the cycle\n  }\n  \n  // Check cache\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent, this is root level\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    return 0;\n  }\n  \n  // Find parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    return 0; // Parent not found, treat as root\n  }\n  \n  // Add current post to visited set\n  visited.add(postId);\n  \n  // Recursively calculate parent's depth\n  const parentDepth = calculateDepthRecursive(parentPost, allPosts, visited);\n  const depth = parentDepth + 1;\n  \n  // Remove from visited set (backtrack)\n  visited.delete(postId);\n  \n  // Apply maximum depth limit to prevent excessive UI indentation\n  return Math.min(depth, MAX_THREAD_DEPTH);\n}\n\n/**\n * Clear the thread depth cache\n * \n * Should be called when posts are updated, removed, or when switching discussions\n * to ensure fresh calculations.\n */\nexport function clearThreadDepthCache() {\n  threadDepthCache.clear();\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * Generates appropriate CSS classes for styling threaded posts.\n * \n * @param {Post} post - The post to generate classes for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {string[]} - Array of CSS classes\n */\nexport function getThreadCssClasses(post, allPosts) {\n  const threadDepth = calculateThreadDepth(post, allPosts);\n  const classes = [];\n  \n  if (threadDepth > 0) {\n    classes.push('Post--threaded');\n    classes.push(`Post--thread-depth-${threadDepth}`);\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * @param {Post} post - The post to check\n * @returns {boolean} - True if the post is a root post\n */\nexport function isRootPost(post) {\n  return !post.attribute('parent_id');\n}\n\n/**\n * Check if a post is a direct reply (depth 1)\n * @param {Post} post - The post to check\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if the post is a direct reply\n */\nexport function isDirectReply(post, allPosts) {\n  return calculateThreadDepth(post, allPosts) === 1;\n} ","import app from 'flarum/forum/app';\nimport { extend, override } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport PostStreamState from 'flarum/forum/states/PostStreamState';\n\nimport { createThreadedPosts } from '../utils/ThreadTree';\nimport { clearThreadDepthCache } from '../utils/ThreadDepth';\nimport { loadMissingParentPosts, loadMinimalChildren } from '../utils/PostLoader';\nimport { prefetchThreadOrder, getOrderIndex } from '../utils/ThreadOrderPrefetch';\n\n// —— 全局状态 —— //\nlet isReordering = false;\nlet reorderedPostsCache = null;\nlet originalPostsMethod = null;\nlet lastPostCount = 0;\nlet currentDiscussionId = null;\n\n// 分页期间：彻底暂停线程化（返回原生 posts），避免 anchorScroll 取不到锚点\nlet suspendThreading = false;\nlet rebuildPending = false;\n\n// 轻量补充：补父 / 少量子（可开关）\nconst enableMinimalChildLoading = true;\n\nexport function initThreadedPostStream() {\n  // 在分页开始/结束时切换“暂停重排”标志，并在结束后补做一次重排\n  override(PostStreamState.prototype, '_loadPrevious', function (original, ...args) {\n    suspendThreading = true;\n    const p = original(...args);\n    return Promise.resolve(p).finally(() => {\n      suspendThreading = false;\n      if (rebuildPending) {\n        rebuildPending = false;\n        const ps = this.discussion && this.discussion.postStream ? this.discussion.postStream : null;\n        if (ps) scheduleRebuild(ps);\n      }\n    });\n  });\n\n  override(PostStreamState.prototype, '_loadNext', function (original, ...args) {\n    suspendThreading = true;\n    const p = original(...args);\n    return Promise.resolve(p).finally(() => {\n      suspendThreading = false;\n      if (rebuildPending) {\n        rebuildPending = false;\n        const ps = this.discussion && this.discussion.postStream ? this.discussion.postStream : null;\n        if (ps) scheduleRebuild(ps);\n      }\n    });\n  });\n\n  // 绑定 PostStream 生命周期\n  extend(PostStream.prototype, 'oninit', function () {\n    const did = this.stream && this.stream.discussion && this.stream.discussion.id();\n    if (currentDiscussionId !== did) resetState(did);\n\n    if (did) prefetchThreadOrder(did);          // 首帧预取全局顺序（非常轻）\n\n    if (!originalPostsMethod) originalPostsMethod = this.stream.posts;\n\n    // 覆盖 posts()：分页中直接返回原生 posts；平时优先返回缓存\n    this.stream.posts = () => {\n      if (suspendThreading) {\n        // 分页期：完全回退到原生顺序，保障 anchorScroll\n        return originalPostsMethod.call(this.stream) || [];\n      }\n      if (reorderedPostsCache) return reorderedPostsCache;\n\n      const original = originalPostsMethod.call(this.stream) || [];\n      // 初载且有内容时拉起一次重排（异步，不阻断首帧）\n      if (!isReordering && original.filter(Boolean).length > 0) {\n        scheduleRebuild(this);\n      }\n      return original;\n    };\n\n    // 记录当前帖子数\n    const cur = originalPostsMethod.call(this.stream) || [];\n    lastPostCount = cur.filter(Boolean).length;\n\n    // 首帧尽量重排（若不在分页中）\n    if (lastPostCount > 0 && !suspendThreading) scheduleRebuild(this);\n  });\n\n  extend(PostStream.prototype, 'oncreate', function () {\n    clearThreadDepthCache();\n  });\n\n  // 帖子数变化：分页中仅做标记，结束后补排；非分页立即重排\n  extend(PostStream.prototype, 'onupdate', function () {\n    if (!originalPostsMethod) return;\n    const current = originalPostsMethod.call(this.stream) || [];\n    const count = current.filter(Boolean).length;\n\n    if (count !== lastPostCount) {\n      lastPostCount = count;\n      reorderedPostsCache = null;\n      clearThreadDepthCache();\n\n      if (suspendThreading) {\n        rebuildPending = true;\n      } else {\n        scheduleRebuild(this);\n      }\n    }\n  });\n}\n\n// ========== 重排主流程 ========== //\n\nfunction scheduleRebuild(postStream) {\n  // 避免同步阻塞渲染\n  setTimeout(() => updateReorderedCache(postStream), 0);\n}\n\nfunction updateReorderedCache(postStream) {\n  if (isReordering) return;\n  if (suspendThreading) {\n    rebuildPending = true;\n    return;\n  }\n  isReordering = true;\n\n  try {\n    if (!originalPostsMethod) return finish(null);\n\n    const originalPosts = originalPostsMethod.call(postStream.stream) || [];\n    const valid = originalPosts.filter(Boolean);\n    if (valid.length === 0) return finish(null);\n\n    ensureParentsLoaded(postStream, valid)\n      .then((postsWithParents) =>\n        enableMinimalChildLoading\n          ? ensureMinimalChildren(postStream, postsWithParents)\n          : postsWithParents\n      )\n      .then((postsReady) => {\n        const did = postStream.stream && postStream.stream.discussion && postStream.stream.discussion.id();\n\n        // —— 优先按 /threads-order 预取顺序排序 —— //\n        const orderOf = (p) => {\n          const id = p && p.id ? p.id() : null;\n          if (!id) return null;\n          const idx = getOrderIndex(did, id);\n          return Number.isInteger(idx) ? idx : null;\n        };\n\n        let sorted;\n        const hasAnyOrder = postsReady.some((p) => orderOf(p) !== null);\n\n        if (hasAnyOrder) {\n          sorted = postsReady.slice().sort((a, b) => {\n            const ao = orderOf(a);\n            const bo = orderOf(b);\n            if (ao == null && bo == null) return 0;\n            if (ao == null) return 1;\n            if (bo == null) return -1;\n            return ao - bo;\n          });\n        } else {\n          // 退回本地“父后跟子”的轻量线程化\n          sorted = createThreadedPosts(postsReady);\n        }\n\n        const threadedArray = padToOriginalLength(originalPosts, sorted);\n        finish(threadedArray);\n      })\n      .catch((err) => {\n        console.warn('[Threadify] reorder fallback due to error:', err);\n        const fallback = createThreadedPosts(valid);\n        const threadedArray = padToOriginalLength(originalPosts, fallback);\n        finish(threadedArray);\n      });\n  } catch (e) {\n    console.error('[Threadify] Cache update failed:', e);\n    finish(null);\n  }\n\n  function finish(arr) {\n    reorderedPostsCache = arr;         // 允许为 null：上层会回退原数组\n    isReordering = false;\n    setTimeout(() => m.redraw(), 0);\n  }\n}\n\nfunction padToOriginalLength(originalPosts, threadedPosts) {\n  if (!Array.isArray(threadedPosts) || threadedPosts.length === 0) return originalPosts;\n  const result = [...threadedPosts];\n  const need = Math.max(0, originalPosts.length - threadedPosts.length);\n  for (let i = 0; i < need; i++) result.push(null); // 只补 null，绝不返回 undefined\n  return result;\n}\n\n// —— 按需补父/少量子（失败即原样返回） —— //\nfunction ensureParentsLoaded(postStream, posts) {\n  if (typeof loadMissingParentPosts === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMissingParentPosts(ctx, posts).catch(() => Promise.resolve(posts));\n  }\n  return Promise.resolve(posts);\n}\nfunction ensureMinimalChildren(postStream, posts) {\n  if (typeof loadMinimalChildren === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMinimalChildren(ctx, posts).catch(() => Promise.resolve(posts));\n  }\n  return Promise.resolve(posts);\n}\n\n// —— 切讨论时复位 —— //\nfunction resetState(discussionId) {\n  currentDiscussionId = discussionId;\n  isReordering = false;\n  reorderedPostsCache = null;\n  originalPostsMethod = null;\n  lastPostCount = 0;\n  suspendThreading = false;\n  rebuildPending = false;\n  clearThreadDepthCache();\n}\n\n// Debug（可选）\nexport function getThreadedPostsCache() { return reorderedPostsCache; }\nexport function forceRebuildCache(ps) { reorderedPostsCache = null; clearThreadDepthCache(); scheduleRebuild(ps); }\nexport function isThreadingActive() { return !!(reorderedPostsCache && originalPostsMethod); }\nexport function getThreadingStats() {\n  return {\n    hasCachedPosts: !!reorderedPostsCache,\n    cachedPostCount: reorderedPostsCache ? reorderedPostsCache.filter(Boolean).length : 0,\n    isReordering, lastPostCount, suspendThreading, rebuildPending, discussionId: currentDiscussionId,\n    hasOriginalMethod: !!originalPostsMethod,\n  };\n}\n","import { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport { forceRebuildCache } from '../components/ThreadedPostStream'; // 你已有的状态重排入口\n\n/**\n * 安装“新增楼层观察器”：\n * - 监听 PostStream 容器内 childList 变化；\n * - 只要出现 .PostStream-item[data-id] 新节点，就合并抖动后触发一次状态级重排；\n * - 不改 display，不用 flex，不碰 Scrubber。\n */\nexport function installNewPostObserver() {\n  extend(PostStream.prototype, 'oncreate', function () {\n    const root = this.element;\n    if (!root) return;\n\n    // 避免重复安装\n    if (this.__threadifyObs) this.__threadifyObs.disconnect();\n\n    let timer = null;\n    const schedule = () => {\n      clearTimeout(timer);\n      // 合并 30ms 内的新增，避免频繁重排\n      timer = setTimeout(() => {\n        try {\n          forceRebuildCache(this); // 走“状态重排”，不改变 DOM 布局方式\n        } catch (e) {\n          console.warn('[threadify] forceRebuildCache failed:', e);\n        }\n      }, 30);\n    };\n\n    const obs = new MutationObserver((mutations) => {\n      // 仅当新增的节点里包含真正的“楼层”才触发\n      const hit = mutations.some((m) =>\n        [...m.addedNodes].some(\n          (n) => n.nodeType === 1 && n.matches && n.matches('.PostStream-item[data-id]')\n        )\n      );\n      if (hit) schedule();\n    });\n\n    obs.observe(root, { childList: true, subtree: true });\n    this.__threadifyObs = obs;\n    this.__threadifyObsTimer = timer;\n  });\n\n  extend(PostStream.prototype, 'onremove', function () {\n    if (this.__threadifyObs) this.__threadifyObs.disconnect();\n    if (this.__threadifyObsTimer) clearTimeout(this.__threadifyObsTimer);\n    this.__threadifyObs = null;\n    this.__threadifyObsTimer = null;\n  });\n}\n","// js/src/forum/index.js\nimport app from 'flarum/forum/app';\nimport { extend } from 'flarum/common/extend';\n\nimport DiscussionPage from 'flarum/forum/components/DiscussionPage';\n\nimport { initThreadedPost } from './components/ThreadedPost';\nimport { initThreadedReplyComposer } from './components/ThreadedReplyComposer';\n\n// 基于 API 的 PostStream 重排（保持分页空洞、兼容 Scrubber）\nimport { installApiThreadedPostStream } from './components/ApiThreadedPostStream';\nimport { prefetchThreadsOrder } from './utils/ThreadsApi';\n\n// 可选：监听新增 .PostStream-item[data-id]，在 Realtime/分页新增时合并触发一次状态重排\nimport { installNewPostObserver } from './utils/NewPostObserver';\n\n/**\n * 日志控制（默认屏蔽，可在控制台开启）\n * 仅影响以 \"[Threadify]\" 开头的日志；其余 console 输出不受影响。\n */\n(function setupThreadifyLoggingToggle() {\n  const NS = '[Threadify]';\n  const KEY = 'threadify:logs';\n  const methods = ['log', 'info', 'warn', 'debug', 'error'];\n\n  if (!window.__threadifyConsoleOriginal) {\n    window.__threadifyConsoleOriginal = {};\n    methods.forEach((name) => {\n      window.__threadifyConsoleOriginal[name] =\n        console[name] ? console[name].bind(console) : () => {};\n    });\n  }\n\n  const persisted =\n    typeof localStorage !== 'undefined' ? localStorage.getItem(KEY) : null;\n  let enabled = persisted === '1';\n\n  function applyWrap() {\n    methods.forEach((name) => {\n      const original = window.__threadifyConsoleOriginal[name];\n      console[name] = (...args) => {\n        const first = args && args[0];\n        const isThreadifyMsg = typeof first === 'string' && first.indexOf(NS) === 0;\n        if (isThreadifyMsg && !enabled) return;\n        return original(...args);\n      };\n    });\n  }\n\n  function setEnabled(v) {\n    enabled = !!v;\n    if (typeof localStorage !== 'undefined') {\n      localStorage.setItem(KEY, enabled ? '1' : '0');\n    }\n  }\n\n  window.threadifyLogs = {\n    enable() { setEnabled(true); return 'Threadify logs: ON'; },\n    disable() { setEnabled(false); return 'Threadify logs: OFF'; },\n    toggle() { setEnabled(!enabled); return `Threadify logs: ${enabled ? 'ON' : 'OFF'}`; },\n    status() { return enabled; },\n  };\n\n  applyWrap();\n})();\n\napp.initializers.add('syntaxoutlaw-threadify', () => {\n  // 1) 仅给帖子元素补充深度类（不改 PostStream 布局）\n  initThreadedPost();\n\n  // 2) 提交时自动抽取 mentions → parent_id\n  initThreadedReplyComposer();\n\n  // 3) 安装“API 线程顺序 + posts() 状态重排”方案（保持分页空洞，Scrubber 可用）\n  installApiThreadedPostStream();\n\n  // 4) 监听新增楼层（Realtime/分页加载），合并抖动后触发一次状态重排\n  installNewPostObserver();\n\n  // 5) 打开讨论页即预取 order（payload 极小，减少首帧重排）\n  extend(DiscussionPage.prototype, 'oninit', function () {\n    const did =\n      (this.discussion && typeof this.discussion.id === 'function' && this.discussion.id()) ||\n      (this.discussion && this.discussion.id) ||\n      null;\n    if (did) prefetchThreadsOrder(did);\n  });\n\n  // 6) 当 /threads-order 预取完成时，若仍在同一讨论页，轻量重绘一次以套用最新顺序\n  window.addEventListener('threadify:order-ready', (ev) => {\n    const readyDid = ev && ev.detail && ev.detail.discussionId;\n    if (!readyDid) return;\n\n    try {\n      const page = app.current && app.current.get && app.current.get('component');\n      const did =\n        (page && page.discussion && typeof page.discussion.id === 'function' && page.discussion.id()) ||\n        (page && page.discussion && page.discussion.id) ||\n        null;\n\n      if (did && String(did) === String(readyDid)) {\n        m.redraw();\n      }\n    } catch (_) {}\n  });\n});\n","/**\n * Threaded Post Component Extensions\n * \n * Handles Post component extensions for threading functionality.\n * This module is responsible for:\n * - Adding threading CSS classes to posts based on their depth\n * - Managing post-specific threading visual elements\n * - Integrating with the ThreadDepth utility for depth calculations\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport Post from 'flarum/forum/components/Post';\nimport { getThreadCssClasses } from '../utils/SimplifiedThreadDepth';\n\n/**\n * Initialize Post component extensions for threading\n * \n * Sets up all the necessary hooks and extensions for the Post component\n * to display threading information properly.\n */\nexport function initThreadedPost() {\n  // Hook into Post component to add threading CSS classes\n  extend(Post.prototype, 'classes', function(classes) {\n    const post = this.attrs.post;\n    \n    // Skip processing if we don't have a valid post\n    if (!post) {\n      console.warn('[Threadify] No post in ThreadedPost.classes');\n      return classes;\n    }\n    \n    // Get threading CSS classes from simplified utility\n    const threadClasses = getThreadCssClasses(post);\n    console.log(`[Threadify] Adding classes to post ${post.id()}: ${threadClasses.join(', ')}`);\n    \n    threadClasses.forEach(className => {\n      classes.push(className);\n    });\n    \n    return classes;\n  });\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts useful threading metadata from a post that can be used\n * by other components or for debugging purposes.\n * \n * @param {Post} post - The post to extract metadata from\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Object} - Thread metadata object\n */\nexport function getPostThreadMetadata(post, allPosts) {\n  if (!post) return null;\n  \n  const parentId = post.attribute('parent_id');\n  const parentPost = parentId ? allPosts.find(p => p && p.id() == parentId) : null;\n  \n  // Find direct children of this post\n  const children = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  // Calculate some thread statistics\n  const descendants = getDescendantCount(post, allPosts);\n  \n  return {\n    postId: post.id(),\n    parentId: parentId,\n    hasParent: !!parentPost,\n    parentPost: parentPost,\n    directChildren: children,\n    childrenCount: children.length,\n    descendantCount: descendants,\n    isRootPost: !parentId,\n    threadClasses: getThreadCssClasses(post, allPosts)\n  };\n}\n\n/**\n * Count all descendants (children, grandchildren, etc.) of a post\n * \n * @param {Post} post - The post to count descendants for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {number} - Total number of descendants\n */\nfunction getDescendantCount(post, allPosts) {\n  const directChildren = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  let count = directChildren.length;\n  \n  // Recursively count descendants of each child\n  directChildren.forEach(child => {\n    count += getDescendantCount(child, allPosts);\n  });\n  \n  return count;\n}\n\n/**\n * Check if a post is part of a specific thread branch\n * \n * Determines if a post is either a descendant or ancestor of another post.\n * Useful for highlighting related posts or collapsing thread branches.\n * \n * @param {Post} post1 - First post\n * @param {Post} post2 - Second post  \n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if posts are in the same thread branch\n */\nexport function arePostsInSameBranch(post1, post2, allPosts) {\n  if (!post1 || !post2 || post1.id() === post2.id()) {\n    return false;\n  }\n  \n  // Check if post1 is an ancestor of post2\n  let currentPost = post2;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post1.id()) {\n      return true; // post1 is an ancestor of post2\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  // Check if post2 is an ancestor of post1\n  currentPost = post1;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post2.id()) {\n      return true; // post2 is an ancestor of post1\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  return false;\n}\n\n/**\n * Get the root post of a thread branch\n * \n * Traces back through parent relationships to find the root post\n * of the thread branch that contains the given post.\n * \n * @param {Post} post - The post to find the root for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Post|null} - The root post of the thread branch\n */\nexport function getThreadRoot(post, allPosts) {\n  if (!post) return null;\n  \n  let currentPost = post;\n  let rootPost = post;\n  \n  // Trace back through parents until we find a post with no parent\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) {\n      rootPost = currentPost;\n      break;\n    }\n    \n    const parentPost = allPosts.find(p => p && p.id() == parentId);\n    if (!parentPost) {\n      // Parent not found, current post becomes the effective root\n      rootPost = currentPost;\n      break;\n    }\n    \n    rootPost = parentPost;\n    currentPost = parentPost;\n  }\n  \n  return rootPost;\n} \n","/**\n * Threaded Reply Composer Extensions\n * \n * Handles ReplyComposer component extensions for threading functionality.\n * This module is responsible for:\n * - Extracting parent_id from post mentions in reply content\n * - Adding parent_id to the reply data before submission\n * - Integrating with Flarum's mentions extension for seamless threading\n * \n * The threading system works by detecting post mentions in the format:\n * @\"Display Name\"#p123 where 123 is the post ID that becomes the parent_id\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport ReplyComposer from 'flarum/forum/components/ReplyComposer';\n\n/**\n * Initialize ReplyComposer component extensions for threading\n * \n * Sets up hooks to automatically detect and add parent_id relationships\n * when users reply to specific posts using the mentions system.\n */\nexport function initThreadedReplyComposer() {\n  // Hook into reply submission to add parent_id\n  extend(ReplyComposer.prototype, 'data', function(data) {\n    const parentId = extractParentIdFromContent(data.content);\n    \n    if (parentId) {\n      // Add parent_id directly to the data object\n      data.parent_id = parentId;\n      console.log('[Threadify] Reply threading to post', parentId);\n    }\n    \n    return data;\n  });\n}\n\n/**\n * Extract parent post ID from reply content\n * \n * Parses the reply content for post mentions from the mentions extension\n * and extracts the post ID to use as parent_id for threading.\n * \n * Supported mention formats:\n * - @\"Display Name\"#p123 (standard post mention)\n * - Multiple mentions (uses the first one found)\n * \n * @param {string} content - The reply content to parse\n * @returns {number|null} - The parent post ID or null if none found\n */\nexport function extractParentIdFromContent(content) {\n  if (!content || typeof content !== 'string') {\n    return null;\n  }\n  \n  // Parse the content for post mentions from the mentions extension\n  // Format: @\"Display Name\"#p123 where 123 is the post ID\n  const postMentionMatch = content.match(/@\"[^\"]*\"#p(\\d+)/);\n  \n  if (postMentionMatch && postMentionMatch[1]) {\n    const parentId = parseInt(postMentionMatch[1], 10);\n    \n    // Validate that it's a valid number\n    if (!isNaN(parentId) && parentId > 0) {\n      return parentId;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract all mentioned post IDs from content\n * \n * Gets all post mentions from the content, not just the first one.\n * Useful for analytics or advanced threading features.\n * \n * @param {string} content - The reply content to parse\n * @returns {number[]} - Array of mentioned post IDs\n */\nexport function extractAllMentionedPostIds(content) {\n  if (!content || typeof content !== 'string') {\n    return [];\n  }\n  \n  const postMentionRegex = /@\"[^\"]*\"#p(\\d+)/g;\n  const matches = [];\n  let match;\n  \n  while ((match = postMentionRegex.exec(content)) !== null) {\n    const postId = parseInt(match[1], 10);\n    if (!isNaN(postId) && postId > 0) {\n      matches.push(postId);\n    }\n  }\n  \n  return matches;\n}\n\n/**\n * Check if content contains post mentions\n * \n * @param {string} content - The content to check\n * @returns {boolean} - True if content contains post mentions\n */\nexport function hasPostMentions(content) {\n  return extractParentIdFromContent(content) !== null;\n}\n\n/**\n * Get threading context from reply content\n * \n * Extracts comprehensive threading information from reply content,\n * including the primary parent and any additional mentioned posts.\n * \n * @param {string} content - The reply content to analyze\n * @returns {Object} - Threading context object\n */\nexport function getThreadingContext(content) {\n  const primaryParentId = extractParentIdFromContent(content);\n  const allMentionedIds = extractAllMentionedPostIds(content);\n  \n  return {\n    primaryParentId: primaryParentId,\n    allMentionedPostIds: allMentionedIds,\n    hasMentions: allMentionedIds.length > 0,\n    mentionCount: allMentionedIds.length,\n    isThreadedReply: primaryParentId !== null\n  };\n}\n\n/**\n * Validate threading data before submission\n * \n * Performs validation on the threading data to ensure it's valid\n * before the reply is submitted to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Validation result with isValid boolean and any error messages\n */\nexport function validateThreadingData(data) {\n  const result = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check if parent_id is present and valid\n  if (data.parent_id !== undefined) {\n    if (typeof data.parent_id !== 'number' || data.parent_id <= 0) {\n      result.isValid = false;\n      result.errors.push('Invalid parent_id: must be a positive number');\n    }\n  }\n  \n  // Check for potential threading issues\n  if (data.content && hasPostMentions(data.content)) {\n    const context = getThreadingContext(data.content);\n    \n    if (!data.parent_id && context.isThreadedReply) {\n      result.warnings.push('Content contains post mentions but no parent_id was set');\n    }\n    \n    if (context.mentionCount > 1) {\n      result.warnings.push(`Multiple post mentions found (${context.mentionCount}), only first will be used for threading`);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Clean threading data for submission\n * \n * Ensures threading data is properly formatted and cleaned before\n * being sent to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Cleaned data object\n */\nexport function cleanThreadingData(data) {\n  const cleanedData = { ...data };\n  \n  // Ensure parent_id is a proper integer or remove it\n  if (cleanedData.parent_id !== undefined) {\n    const parentId = parseInt(cleanedData.parent_id, 10);\n    if (!isNaN(parentId) && parentId > 0) {\n      cleanedData.parent_id = parentId;\n    } else {\n      delete cleanedData.parent_id;\n    }\n  }\n  \n  return cleanedData;\n} "],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","flarum","core","compat","_cache","Map","prefetchThreadsOrder","discussionId","did","Number","Promise","resolve","hit","ready","entry","map","set","app","request","method","url","forum","attribute","then","res","order","forEach","_ref","postId","depth","parentPostId","isFinite","parentId","window","dispatchEvent","CustomEvent","detail","e","console","warn","getOrderRecord","getPostThreadMetadata","post","discussion","id","rec","threadPath","isRoot","childCount","descendantCount","rootPostId","clampDepth","n","x","Math","max","min","getThreadCssClasses","String","undefined","getDepthPrefetched","isInteger","_","md","guard","seen","Set","current","pid","has","add","parent","store","getById","walkDepthByParentChain","getThreadDepth","classes","push","prefParent","getParentPrefetched","currentDid","cached","lastCount","originalGetter","buildCacheIfNeeded","ps","stream","raw","length","loadedCount","filter","size","originalArr","arr","slice","L","R","segment","Boolean","sort","b","ra","rb","oa","MAX_SAFE_INTEGER","ob","result","p","i","reorderWithinLoadedSegment","threadDepthCache","isReordering","scheduleRebuild","postStream","setTimeout","finish","error","m","redraw","updateReorderedCache","installNewPostObserver","extend","PostStream","root","this","element","__threadifyObs","disconnect","timer","obs","MutationObserver","mutations","some","concat","addedNodes","nodeType","matches","clearTimeout","clear","observe","childList","subtree","__threadifyObsTimer","KEY","methods","__threadifyConsoleOriginal","name","bind","enabled","localStorage","getItem","setEnabled","v","setItem","threadifyLogs","enable","disable","toggle","status","original","_len","arguments","args","Array","_key","first","indexOf","apply","Post","attrs","threadClasses","log","join","className","ReplyComposer","data","content","postMentionMatch","match","parseInt","isNaN","extractParentIdFromContent","parent_id","posts","ret","DiscussionPage","addEventListener","ev","readyDid","page"],"sourceRoot":""}