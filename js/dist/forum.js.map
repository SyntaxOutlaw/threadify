{"version":3,"file":"forum.js","mappings":"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","sources":["webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/extend']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/app']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/PostStream']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/states/PostStreamState']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/components/LoadingIndicator']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadTree.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/PostLoader.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/bootstrap","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/compat get default export","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/define property getters","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/hasOwnProperty shorthand","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/make namespace object","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/Post']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadsApi.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/ReplyComposer']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/index.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPost.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/SimplifiedThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedReplyComposer.js"],"sourcesContent":["module.exports = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/app'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/PostStream'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/states/PostStreamState'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/components/LoadingIndicator'];","/**\n * Thread Tree Utilities\n * \n * Handles building and flattening thread tree structures from Flarum posts.\n * This module is responsible for:\n * - Building hierarchical thread structures from flat post arrays\n * - Flattening thread trees back to linear arrays in threaded order\n * - Maintaining parent-child relationships between posts\n * \n * @author Threadify Extension\n */\n\n/**\n * Build a threaded tree structure from posts\n * \n * Takes a flat array of posts and organizes them into a hierarchical tree\n * structure based on their parent_id attributes. Posts without a parent_id\n * become root posts, while posts with parent_id become children of their\n * respective parents.\n * \n * @param {Post[]} posts - All posts in the discussion\n * @returns {Post[]} - Array of root posts with _threadChildren attached\n */\nexport function buildThreadTree(posts) {\n  const tree = [];\n  const postMap = new Map();\n  const childrenMap = new Map();\n  \n  // First pass: create post map and initialize children arrays\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    postMap.set(postId, post);\n    childrenMap.set(postId, []);\n  });\n  \n  // Second pass: organize posts by parent-child relationships\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    const parentId = post.attribute('parent_id');\n    \n    if (parentId && postMap.has(String(parentId))) {\n      // This post has a parent, add it to parent's children\n      childrenMap.get(String(parentId)).push(post);\n    } else {\n      // This is a root post (no parent or parent not found)\n      tree.push(post);\n    }\n  });\n  \n  // Third pass: attach children to posts for easy access\n  posts.forEach(post => {\n    if (!post) return;\n    post._threadChildren = childrenMap.get(post.id()) || [];\n  });\n  \n  return tree;\n}\n\n/**\n * Flatten thread tree back to linear array in threaded order\n * \n * Takes a hierarchical tree of posts and flattens it back to a linear array\n * while maintaining the threaded order (parent followed by all its children\n * recursively). This preserves the threading visual structure when posts\n * are rendered linearly.\n * \n * @param {Post[]} rootPosts - Root posts with their children attached via _threadChildren\n * @returns {Post[]} - Flattened array in threaded order\n */\nexport function flattenThreadTree(rootPosts) {\n  const result = [];\n  \n  /**\n   * Recursively add a post and all its children to the result array\n   * @param {Post} post - The post to add\n   * @param {number} depth - Current nesting depth (for potential future use)\n   */\n  function addPostAndChildren(post, depth = 0) {\n    if (!post) return;\n    \n    result.push(post);\n    \n    // Get children and sort them chronologically within each thread level\n    const children = post._threadChildren || [];\n    children.sort((a, b) => {\n      const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n      const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n      return timeA - timeB;\n    });\n    \n    // Recursively add all children\n    children.forEach(child => {\n      addPostAndChildren(child, depth + 1);\n    });\n  }\n  \n  // Sort root posts chronologically to maintain discussion flow\n  rootPosts.sort((a, b) => {\n    const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n    const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n    return timeA - timeB;\n  });\n  \n  // Add each root post and its entire thread branch\n  rootPosts.forEach(rootPost => {\n    addPostAndChildren(rootPost);\n  });\n  \n  return result;\n}\n\n/**\n * Create a threaded post array from flat posts\n * \n * Convenience function that combines buildThreadTree and flattenThreadTree\n * to convert a flat array of posts directly into threaded order.\n * \n * @param {Post[]} posts - Flat array of posts\n * @returns {Post[]} - Posts reordered in threaded structure\n */\nexport function createThreadedPosts(posts) {\n  const threadTree = buildThreadTree(posts);\n  return flattenThreadTree(threadTree);\n} ","/**\n * Thread Depth Calculator\n * \n * Handles calculating and caching thread depth for posts.\n * Thread depth determines how many levels deep a post is in a thread\n * (0 = root post, 1 = direct reply, 2 = reply to reply, etc.)\n * \n * Uses caching to avoid expensive recalculations and includes cycle detection\n * to prevent infinite loops in case of malformed parent relationships.\n * \n * @author Threadify Extension\n */\n\n// Cache for thread depth calculations to avoid recalculating\nconst threadDepthCache = new Map();\n\n// Maximum allowed thread depth to prevent excessive UI indentation\nconst MAX_THREAD_DEPTH = 10;\n\n/**\n * Calculate the thread depth of a post\n * \n * Determines how many levels deep a post is in the thread hierarchy.\n * Uses caching for performance and includes cycle detection for safety.\n * \n * @param {Post} post - The post to calculate depth for\n * @param {Post[]} allPosts - All posts in the discussion (for parent lookup)\n * @returns {number} - The depth (0 = root, 1 = direct reply, etc.)\n */\nexport function calculateThreadDepth(post, allPosts) {\n  const postId = post.id();\n  \n  // Check cache first for performance\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent_id, this is a root post (depth 0)\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Find the parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    // Parent not found, treat as root\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Cycle detection: if we're calculating depth for a post that's already\n  // in our calculation chain, we have a cycle\n  const visited = new Set();\n  const depth = calculateDepthRecursive(post, allPosts, visited);\n  \n  // Cache and return the calculated depth\n  threadDepthCache.set(postId, depth);\n  return depth;\n}\n\n/**\n * Recursive helper for depth calculation with cycle detection\n * @param {Post} post - Current post\n * @param {Post[]} allPosts - All posts for parent lookup\n * @param {Set} visited - Set of visited post IDs to detect cycles\n * @returns {number} - Calculated depth\n */\nfunction calculateDepthRecursive(post, allPosts, visited) {\n  const postId = post.id();\n  \n  // Cycle detection\n  if (visited.has(postId)) {\n    console.warn(`[Threadify] Cycle detected for post ${postId}`);\n    return 0; // Treat cyclic posts as root to break the cycle\n  }\n  \n  // Check cache\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent, this is root level\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    return 0;\n  }\n  \n  // Find parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    return 0; // Parent not found, treat as root\n  }\n  \n  // Add current post to visited set\n  visited.add(postId);\n  \n  // Recursively calculate parent's depth\n  const parentDepth = calculateDepthRecursive(parentPost, allPosts, visited);\n  const depth = parentDepth + 1;\n  \n  // Remove from visited set (backtrack)\n  visited.delete(postId);\n  \n  // Apply maximum depth limit to prevent excessive UI indentation\n  return Math.min(depth, MAX_THREAD_DEPTH);\n}\n\n/**\n * Clear the thread depth cache\n * \n * Should be called when posts are updated, removed, or when switching discussions\n * to ensure fresh calculations.\n */\nexport function clearThreadDepthCache() {\n  threadDepthCache.clear();\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * Generates appropriate CSS classes for styling threaded posts.\n * \n * @param {Post} post - The post to generate classes for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {string[]} - Array of CSS classes\n */\nexport function getThreadCssClasses(post, allPosts) {\n  const threadDepth = calculateThreadDepth(post, allPosts);\n  const classes = [];\n  \n  if (threadDepth > 0) {\n    classes.push('Post--threaded');\n    classes.push(`Post--thread-depth-${threadDepth}`);\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * @param {Post} post - The post to check\n * @returns {boolean} - True if the post is a root post\n */\nexport function isRootPost(post) {\n  return !post.attribute('parent_id');\n}\n\n/**\n * Check if a post is a direct reply (depth 1)\n * @param {Post} post - The post to check\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if the post is a direct reply\n */\nexport function isDirectReply(post, allPosts) {\n  return calculateThreadDepth(post, allPosts) === 1;\n} ","/**\n * Post Loader Utilities\n * \n * Handles loading missing posts that are needed for complete thread rendering.\n * This includes both parent posts (referenced by loaded posts) and child posts\n * (that reference loaded posts as parents).\n * \n * Uses surgical API calls to minimize data transfer and maintains proper\n * error handling for robust operation.\n * \n * @author Threadify Extension\n */\n\n/**\n * Load missing parent posts that are referenced but not currently loaded\n * \n * Scans currently loaded posts for parent_id references and loads any\n * referenced posts that aren't already loaded. This ensures complete\n * thread chains are available for proper threading display.\n * \n * @param {PostStream} postStream - The PostStream instance\n * @param {Post[]} currentPosts - Currently loaded posts\n * @returns {Promise<Post[]>} - Promise resolving to all posts (current + loaded parents)\n */\nexport function loadMissingParentPosts(postStream, currentPosts) {\n  const currentPostIds = new Set(currentPosts.map(p => p.id()));\n  const missingParentIds = [];\n  \n  // Scan all visible posts for parent_id references\n  currentPosts.forEach(post => {\n    const parentId = post.attribute('parent_id');\n    if (parentId && !currentPostIds.has(String(parentId))) {\n      // This post references a parent that isn't currently loaded\n      missingParentIds.push(String(parentId));\n    }\n  });\n  \n  // Remove duplicates\n  const uniqueMissingIds = Array.from(new Set(missingParentIds));\n  \n  if (uniqueMissingIds.length === 0) {\n    // No missing parents, return current posts\n    return Promise.resolve(currentPosts);\n  }\n  \n  console.log(`[Threadify] Loading ${uniqueMissingIds.length} missing parent posts`);\n  \n  // Load missing parent posts via API\n  return loadPostsByIds(uniqueMissingIds)\n    .then(loadedParents => {\n      \n      // Combine current posts with loaded parents\n      const allPosts = [...currentPosts, ...loadedParents];\n      \n      // Recursively check if the newly loaded parents also have missing parents\n      // This handles deep threading chains where parents also have parents\n      return loadMissingParentPosts(postStream, allPosts);\n    })\n    .catch(error => {\n      console.warn('[Threadify] Failed to load parent posts:', error);\n      return currentPosts; // Return current posts if loading fails\n    });\n}\n\n/**\n * Load missing child posts that reference currently visible posts as parents\n * \n * Loads posts from the discussion that aren't currently visible but reference\n * visible posts as their parents. This ensures child replies are shown even\n * if they weren't initially loaded in the current view.\n * \n * @param {PostStream} postStream - The PostStream instance  \n * @param {Post[]} currentPosts - Currently loaded posts (including any loaded parents)\n * @returns {Promise<Post[]>} - Promise resolving to all posts (current + loaded children)\n */\nexport function loadMissingChildren(postStream, currentPosts) {\n  const currentPostIds = currentPosts.map(p => p.id());\n  \n  if (currentPostIds.length === 0) {\n    return Promise.resolve(currentPosts);\n  }\n  \n  // Get all post IDs in the discussion\n  const discussionPostIds = postStream.discussion.postIds();\n  const loadedPostIdSet = new Set(currentPostIds.map(id => String(id)));\n  \n  // Find unloaded posts that might be children\n  const unloadedPostIds = discussionPostIds.filter(id => !loadedPostIdSet.has(String(id)));\n  \n  if (unloadedPostIds.length === 0) {\n    return Promise.resolve(currentPosts);\n  }\n  \n  // Be more conservative - only load a small sample of recent posts\n  // This reduces the \"janky reloading\" by not loading too many posts at once\n  const sampleSize = Math.min(10, unloadedPostIds.length); // Reduced from 30 to 10\n  const recentUnloaded = unloadedPostIds.slice(-sampleSize); // Get most recent posts\n  \n  console.log(`[Threadify] Checking ${sampleSize} recent unloaded posts for children`);\n  \n  // Load sample posts to check if any are children of visible posts\n  return loadPostsByIds(recentUnloaded)\n    .then(loadedSamplePosts => {\n      // Filter for posts that are actually children of currently visible posts\n      const actualChildren = loadedSamplePosts.filter(post => {\n        const parentId = post.attribute('parent_id');\n        return parentId && currentPostIds.includes(String(parentId));\n      });\n      \n      console.log(`[Threadify] Found ${actualChildren.length} actual children from sample`);\n      \n      if (actualChildren.length > 0) {\n        // Add the children to our current posts\n        const allPostsWithChildren = [...currentPosts, ...actualChildren];\n        \n        // Don't recursively check for more children to avoid excessive loading\n        // This prevents the cascade of API calls that causes \"janky reloading\"\n        return allPostsWithChildren;\n      } else {\n        return currentPosts;\n      }\n    })\n    .catch(error => {\n      console.warn('[Threadify] Failed to load child posts:', error);\n      return currentPosts;\n    });\n}\n\n/**\n * Load complete thread context for given posts\n * \n * Convenience function that loads both missing parents and children\n * for a complete threading context.\n * \n * @param {PostStream} postStream - The PostStream instance\n * @param {Post[]} posts - Initial posts to build context around\n * @returns {Promise<Post[]>} - Promise resolving to posts with complete thread context\n */\nexport function loadCompleteThreadContext(postStream, posts) {\n  return loadMissingParentPosts(postStream, posts)\n    .then(postsWithParents => loadMissingChildren(postStream, postsWithParents))\n    .then(allPosts => {\n      return allPosts;\n    })\n    .catch(error => {\n      console.warn('[Threadify] Failed to load thread context:', error);\n      return posts; // Fallback to original posts\n    });\n}\n\n/**\n * Load only missing child posts (conservative approach)\n * \n * Much more conservative than loadCompleteThreadContext - only loads\n * a small number of recent children, no parents, no recursion.\n * \n * @param {PostStream} postStream - The PostStream instance\n * @param {Post[]} currentPosts - Currently loaded posts\n * @returns {Promise<Post[]>} - Promise resolving to posts with minimal children added\n */\nexport function loadMinimalChildren(postStream, currentPosts) {\n  const currentPostIds = currentPosts.map(p => p.id());\n  \n  if (currentPostIds.length === 0) {\n    return Promise.resolve(currentPosts);\n  }\n  \n  // Get all post IDs in the discussion\n  const discussionPostIds = postStream.discussion.postIds();\n  const loadedPostIdSet = new Set(currentPostIds.map(id => String(id)));\n  \n  // Find unloaded posts that might be children\n  const unloadedPostIds = discussionPostIds.filter(id => !loadedPostIdSet.has(String(id)));\n  \n  if (unloadedPostIds.length === 0) {\n    return Promise.resolve(currentPosts);\n  }\n  \n  // Be very conservative - only load a tiny sample of the most recent posts\n  const sampleSize = Math.min(5, unloadedPostIds.length); // Very small sample\n  const recentUnloaded = unloadedPostIds.slice(-sampleSize);\n  \n  console.log(`[Threadify] Checking only ${sampleSize} recent posts for children`);\n  \n  // Load sample posts to check if any are children of visible posts\n  return loadPostsByIds(recentUnloaded)\n    .then(loadedSamplePosts => {\n      // Filter for posts that are actually children of currently visible posts\n      const actualChildren = loadedSamplePosts.filter(post => {\n        const parentId = post.attribute('parent_id');\n        return parentId && currentPostIds.includes(String(parentId));\n      });\n      \n      console.log(`[Threadify] Found ${actualChildren.length} children from minimal sample`);\n      \n      if (actualChildren.length > 0) {\n        // Add the children to our current posts (no recursion)\n        return [...currentPosts, ...actualChildren];\n      } else {\n        return currentPosts;\n      }\n    })\n    .catch(error => {\n      console.warn('[Threadify] Minimal child loading failed:', error);\n      return currentPosts;\n    });\n}\n\n/**\n * Load posts by their IDs using Flarum's API\n * \n * Makes a surgical API call to load specific posts by ID.\n * Handles the Flarum API format and error cases gracefully.\n * \n * @param {string[]} postIds - Array of post IDs to load\n * @returns {Promise<Post[]>} - Promise resolving to loaded posts\n */\nfunction loadPostsByIds(postIds) {\n  if (!postIds || postIds.length === 0) {\n    return Promise.resolve([]);\n  }\n  \n  // Create the ID string for the API call\n  const idString = postIds.join(',');\n  \n  // Use Flarum's store to load posts with filter parameter\n  return app.store.find('posts', {\n    filter: { id: idString }\n  });\n}\n\n/**\n * Check if posts need thread context loading\n * \n * Determines if the given posts would benefit from loading additional\n * thread context (missing parents or children).\n * \n * @param {Post[]} posts - Posts to check\n * @returns {boolean} - True if context loading would be beneficial\n */\nexport function needsThreadContext(posts) {\n  if (!posts || posts.length === 0) {\n    return false;\n  }\n  \n  const postIds = new Set(posts.map(p => p.id()));\n  \n  // Check if any posts reference parents that aren't loaded\n  const hasMissingParents = posts.some(post => {\n    const parentId = post.attribute('parent_id');\n    return parentId && !postIds.has(String(parentId));\n  });\n  \n  return hasMissingParents;\n} ","/**\n * Threaded PostStream Component Extensions (FIXED + FIRST-FRAME GATING)\n *\n * 变更点：\n * 1) 首帧阻断：若检测到首屏存在“缺失父帖”，先补父帖+建树，再渲染首帧；避免先渲染原始顺序导致的跳动。\n * 2) 双保险接管顺序：覆写 this.stream.posts() + 在 PostStreamState.visiblePosts 稳定排序。\n */\n\nimport app from 'flarum/forum/app';\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport PostStreamState from 'flarum/forum/states/PostStreamState';\nimport LoadingIndicator from 'flarum/common/components/LoadingIndicator';\n\nimport { createThreadedPosts } from '../utils/ThreadTree';\nimport { clearThreadDepthCache } from '../utils/ThreadDepth';\nimport { loadMissingParentPosts, loadMinimalChildren } from '../utils/PostLoader';\n\n// -------- 全局状态 --------\nlet isReordering = false;\nlet reorderedPostsCache = null;\nlet lastPostCount = 0;\nlet originalPostsMethod = null;\nlet currentDiscussionId = null;\nlet threadedOrder = null;\nlet enableMinimalChildLoading = true;\n\n// 首帧阻断相关\nlet firstFrameGated = false;       // 是否需要阻断首帧\nlet firstBuildDone = false;        // 首次建树是否完成\n\nexport function initThreadedPostStream() {\n  // 组件层：初始化\n  extend(PostStream.prototype, 'oninit', function () {\n    const did = this.stream.discussion.id();\n    if (currentDiscussionId !== did) {\n      resetState(did);\n    }\n\n    if (!originalPostsMethod) originalPostsMethod = this.stream.posts;\n\n    // 判定首帧是否需要阻断：首屏可见数组中，只要有任何一个 post 的 parent 不在数组里，就阻断\n    const initial = originalPostsMethod.call(this.stream) || [];\n    const vis = initial.filter(Boolean);\n    firstFrameGated = hasMissingParents(vis);\n    firstBuildDone = false;\n\n    // 覆写 posts()：首帧若阻断且未完成，返回空数组，避免渲染原始顺序\n    this.stream.posts = () => {\n      if (firstFrameGated && !firstBuildDone) {\n        return []; // 阻断首帧：显示 Loading，不渲染原始顺序\n      }\n      if (reorderedPostsCache) return reorderedPostsCache;\n\n      const original = originalPostsMethod.call(this.stream);\n      if (!isReordering && original && original.filter(Boolean).length > 0) {\n        updateReorderedCache(this, { firstKick: true });\n      }\n      return original;\n    };\n\n    // 初始化计数 & 触发首轮构建\n    lastPostCount = vis.length;\n    if (lastPostCount > 0) {\n      updateReorderedCache(this, { firstKick: true });\n    }\n  });\n\n  // 组件层：首帧阻断时，给出小 Loading\n  extend(PostStream.prototype, 'view', function (vdom) {\n    if (firstFrameGated && !firstBuildDone) {\n      return (\n        <div className=\"Threadify-FirstFrameGate\">\n          <LoadingIndicator />\n        </div>\n      );\n    }\n    return vdom;\n  });\n\n  // 组件层：讨论切换\n  extend(PostStream.prototype, 'oncreate', function () {\n    const did = this.stream.discussion.id();\n    if (currentDiscussionId !== did) {\n      resetState(did);\n      const cur = originalPostsMethod ? (originalPostsMethod.call(this.stream) || []) : [];\n      lastPostCount = cur.filter(Boolean).length;\n\n      // 重新评估是否需要阻断\n      firstFrameGated = hasMissingParents(cur.filter(Boolean));\n      firstBuildDone = false;\n\n      if (lastPostCount > 0) updateReorderedCache(this, { firstKick: true });\n    }\n    clearThreadDepthCache();\n  });\n\n  // 组件层：可见数量变化则重建（不再阻断，只有首帧阻断）\n  extend(PostStream.prototype, 'onupdate', function () {\n    if (!originalPostsMethod) return;\n    const current = originalPostsMethod.call(this.stream) || [];\n    const count = current.filter(Boolean).length;\n    if (count !== lastPostCount) {\n      lastPostCount = count;\n      reorderedPostsCache = null;\n      threadedOrder = null;\n      clearThreadDepthCache();\n      updateReorderedCache(this);\n    }\n  });\n\n  // 状态层：按线程顺序稳定排序（兜底）\n  extend(PostStreamState.prototype, 'visiblePosts', function (result) {\n    if (!threadedOrder || !Array.isArray(result) || result.length <= 1) return;\n    result.sort((a, b) => {\n      const ai = a && a.id ? threadedOrder.get(a.id()) : undefined;\n      const bi = b && b.id ? threadedOrder.get(b.id()) : undefined;\n      if (ai == null && bi == null) return 0;\n      if (ai == null) return 1;\n      if (bi == null) return -1;\n      return ai - bi;\n    });\n  });\n}\n\n// ----------------- 核心：构建/刷新缓存 -----------------\nfunction updateReorderedCache(postStream, { firstKick = false } = {}) {\n  if (isReordering) return;\n  isReordering = true;\n\n  try {\n    if (!originalPostsMethod) {\n      finishWith(null);\n      return;\n    }\n\n    const originalPosts = originalPostsMethod.call(postStream.stream) || [];\n    const validPosts = originalPosts.filter(Boolean);\n    if (validPosts.length === 0) {\n      finishWith(null);\n      return;\n    }\n\n    // 若首帧阻断，强制先补齐父帖；否则按常规逻辑\n    const ensureParents = ensureParentsLoaded(postStream, validPosts);\n\n    ensureParents\n      .then((postsWithParents) =>\n        enableMinimalChildLoading\n          ? ensureMinimalChildren(postStream, postsWithParents)\n          : postsWithParents\n      )\n      .then((postsReady) => {\n        const threaded = createThreadedPosts(postsReady);\n        const threadedArray = createThreadedPostsArray(originalPosts, threaded);\n\n        // 建立顺序映射\n        threadedOrder = new Map();\n        let idx = 0;\n        threadedArray.forEach((p) => {\n          if (p && p.id) threadedOrder.set(p.id(), idx++);\n        });\n\n        finishWith(threadedArray);\n      })\n      .catch((err) => {\n        console.warn('[Threadify] parent/child load failed, fallback threading:', err);\n        const threaded = createThreadedPosts(validPosts);\n        const threadedArray = createThreadedPostsArray(originalPosts, threaded);\n\n        threadedOrder = new Map();\n        let idx = 0;\n        threadedArray.forEach((p) => {\n          if (p && p.id) threadedOrder.set(p.id(), idx++);\n        });\n\n        finishWith(threadedArray);\n      });\n\n  } catch (e) {\n    console.error('[Threadify] Cache update failed:', e);\n    finishWith(null);\n  }\n\n  function finishWith(arrayOrNull) {\n    reorderedPostsCache = arrayOrNull;\n    isReordering = false;\n    firstBuildDone = true;   // 解除首帧阻断\n    setTimeout(() => m.redraw(), 0);\n  }\n}\n\n// 维持分页长度：线程顺序 + 末尾 null 占位\nfunction createThreadedPostsArray(originalPosts, threadedPosts) {\n  if (!Array.isArray(threadedPosts) || threadedPosts.length === 0) {\n    return originalPosts;\n  }\n  const result = [...threadedPosts];\n  const nullsNeeded = Math.max(0, originalPosts.length - threadedPosts.length);\n  for (let i = 0; i < nullsNeeded; i++) result.push(null);\n  return result;\n}\n\n// 判定首屏是否缺父帖\nfunction hasMissingParents(posts) {\n  const set = new Set(posts.map((p) => String(p.id())));\n  for (const p of posts) {\n    const pid = p && p.attribute ? p.attribute('parent_id') : null;\n    if (pid && !set.has(String(pid))) return true;\n  }\n  return false;\n}\n\n// ----------------- 父/子帖补全（含本地兜底） -----------------\nfunction ensureParentsLoaded(postStream, posts) {\n  if (typeof loadMissingParentPosts === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMissingParentPosts(ctx, posts).catch(() => fallbackLoadParents(posts));\n  }\n  return fallbackLoadParents(posts);\n}\n\nfunction ensureMinimalChildren(postStream, posts) {\n  if (typeof loadMinimalChildren === 'function') {\n    const ctx = postStream.discussion ? postStream : { discussion: postStream.stream.discussion };\n    return loadMinimalChildren(ctx, posts).catch(() => posts);\n  }\n  return Promise.resolve(posts);\n}\n\n// 兜底：直接通过 API 递归补齐所有缺失父帖\nfunction fallbackLoadParents(currentPosts) {\n  const byId = new Map(currentPosts.filter(Boolean).map((p) => [String(p.id()), p]));\n  const missing = [];\n\n  currentPosts.forEach((p) => {\n    const pid = p && p.attribute ? p.attribute('parent_id') : null;\n    if (pid && !byId.has(String(pid))) missing.push(String(pid));\n  });\n\n  if (missing.length === 0) return Promise.resolve(currentPosts);\n\n  return app.store\n    .find('posts', { filter: { id: missing.join(',') } })\n    .then((loadedParents) => {\n      const combined = [...currentPosts, ...loadedParents];\n      // 递归直到没有缺失父帖\n      return fallbackLoadParents(combined);\n    })\n    .catch(() => currentPosts);\n}\n\n// ----------------- 状态 & 调试导出 -----------------\nexport function getThreadedPostsCache() {\n  return reorderedPostsCache;\n}\n\nexport function forceRebuildCache(postStream) {\n  reorderedPostsCache = null;\n  threadedOrder = null;\n  clearThreadDepthCache();\n  updateReorderedCache(postStream);\n}\n\nexport function isThreadingActive() {\n  return !!(reorderedPostsCache && originalPostsMethod);\n}\n\nexport function getThreadingStats() {\n  return {\n    hasCachedPosts: !!reorderedPostsCache,\n    cachedPostCount: reorderedPostsCache ? reorderedPostsCache.filter(Boolean).length : 0,\n    isReordering,\n    lastPostCount,\n    hasOriginalMethod: !!originalPostsMethod,\n    discussionId: currentDiscussionId,\n    firstFrameGated,\n    firstBuildDone,\n  };\n}\n\nexport function getThreadingDebugInfo() {\n  const info = getThreadingStats();\n  if (reorderedPostsCache) {\n    info.sample =\n      reorderedPostsCache\n        .filter(Boolean)\n        .slice(0, 10)\n        .map((p) => `#${p.id()}(parent:${p.attribute('parent_id') || 'none'})`) || [];\n  }\n  return info;\n}\n\nexport function logThreadingDebug() {\n  console.log('[Threadify] Debug:', getThreadingDebugInfo());\n}\n\nexport function setMinimalChildLoading(enabled) {\n  enableMinimalChildLoading = !!enabled;\n  console.log(`[Threadify] Minimal child loading ${enableMinimalChildLoading ? 'enabled' : 'disabled'}`);\n}\n\n// ----------------- 工具 -----------------\nfunction resetState(discussionId) {\n  currentDiscussionId = discussionId;\n  isReordering = false;\n  reorderedPostsCache = null;\n  lastPostCount = 0;\n  originalPostsMethod = null;\n  threadedOrder = null;\n  firstFrameGated = false;\n  firstBuildDone = false;\n  clearThreadDepthCache();\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/Post'];","/**\n * Threads API Utilities\n * \n * Simple API interface for loading threaded post data from the new\n * threadify_threads table. This replaces the complex dynamic threading\n * logic with efficient pre-computed thread structures.\n * \n * @author Threadify Extension\n */\n\n/**\n * Load all threads for a discussion\n * \n * Makes a single API call to get complete thread structure with all\n * posts in proper threaded order. No complex post loading or tree\n * building needed on the frontend.\n * \n * @param {number} discussionId - The discussion ID to load threads for\n * @returns {Promise<Object[]>} - Promise resolving to array of thread objects\n */\nexport function loadDiscussionThreads(discussionId) {\n  console.log(`[Threadify] Loading threads for discussion ${discussionId}`);\n  \n  // Use Flarum's request method to call our custom API endpoint\n  return app.request({\n    method: 'GET',\n    url: app.forum.attribute('apiUrl') + '/discussions/' + discussionId + '/threads'\n  }).then(response => {\n    console.log(`[Threadify] Loaded ${response.data.length} thread entries`);\n    \n    // Process included data first to populate the store\n    if (response.included) {\n      console.log(`[Threadify] Processing ${response.included.length} included items`);\n      response.included.forEach(item => {\n        console.log(`[Threadify] Including ${item.type}:${item.id}`);\n        app.store.pushObject(item);\n      });\n    }\n    \n    // Convert thread data to posts with threading metadata\n    const threadedPosts = response.data.map(threadData => {\n      // Find the post in Flarum's store\n      const postId = threadData.attributes.postId;\n      let post = app.store.getById('posts', postId);\n      \n      if (post) {\n        // Debug: Check if post has user relationship\n        console.log(`[Threadify] Post ${postId} found, user:`, post.user ? post.user() : 'NO USER');\n        \n        // Add threading metadata to the post\n        post._threadDepth = threadData.attributes.depth;\n        post._threadPath = threadData.attributes.threadPath;\n        post._isRoot = threadData.attributes.isRoot;\n        post._childCount = threadData.attributes.childCount;\n        post._descendantCount = threadData.attributes.descendantCount;\n        post._rootPostId = threadData.attributes.rootPostId;\n        post._parentPostId = threadData.attributes.parentPostId;\n        \n        console.log(`[Threadify] Post ${postId} depth: ${post._threadDepth}, path: ${post._threadPath}`);\n      } else {\n        console.warn(`[Threadify] Post ${postId} not found in store`);\n      }\n      \n      return post;\n    }).filter(post => post !== null); // Filter out any null posts\n    \n    console.log(`[Threadify] Processed ${threadedPosts.length} threaded posts`);\n    \n    return threadedPosts;\n  }).catch(error => {\n    console.error('[Threadify] Failed to load discussion threads:', error);\n    \n    // Fallback: return empty array - existing PostStream will handle this gracefully\n    return [];\n  });\n}\n\n/**\n * Check if threads API is available for a discussion\n * \n * @param {Discussion} discussion - The discussion to check\n * @returns {boolean} - True if threads API should be used\n */\nexport function shouldUseThreadsApi(discussion) {\n  // For now, always try to use the threads API\n  // In the future, this could be configurable or based on discussion settings\n  return true;\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts threading information that was added by loadDiscussionThreads\n * \n * @param {Post} post - The post to get metadata for\n * @returns {Object|null} - Thread metadata or null if not available\n */\nexport function getPostThreadMetadata(post) {\n  if (!post || typeof post._threadDepth === 'undefined') {\n    return null;\n  }\n  \n  return {\n    depth: post._threadDepth,\n    threadPath: post._threadPath,\n    isRoot: post._isRoot,\n    childCount: post._childCount,\n    descendantCount: post._descendantCount,\n    rootPostId: post._rootPostId\n  };\n}\n\n/**\n * Check if a post has threading metadata\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post has threading metadata\n */\nexport function hasThreadMetadata(post) {\n  return post && typeof post._threadDepth !== 'undefined';\n} ","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/ReplyComposer'];","// Threadify Extension - Main Entry Point (fixed)\nimport { initThreadedPostStream } from './components/ThreadedPostStream';\nimport { initThreadedPost } from './components/ThreadedPost';\nimport { initThreadedReplyComposer } from './components/ThreadedReplyComposer';\n\napp.initializers.add('syntaxoutlaw-threadify', () => {\n  try {\n    // 使用稳定版（基于 PostStreamState 的可见页包裹），不要启用简化版 API 流程\n    initThreadedPostStream();\n    initThreadedPost();\n    initThreadedReplyComposer();\n\n    console.log('[Threadify] stable PostStreamState wrapper loaded');\n\n    // 便捷调试\n    window.threadifyDebug = {\n      forceRebuild: (ps) => {\n        const { forceRebuildCache } = require('./components/ThreadedPostStream');\n        forceRebuildCache(ps);\n      }\n    };\n  } catch (e) {\n    console.error('[Threadify] init failed:', e);\n  }\n});\n","/**\n * Threaded Post Component Extensions\n * \n * Handles Post component extensions for threading functionality.\n * This module is responsible for:\n * - Adding threading CSS classes to posts based on their depth\n * - Managing post-specific threading visual elements\n * - Integrating with the ThreadDepth utility for depth calculations\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport Post from 'flarum/forum/components/Post';\nimport { getThreadCssClasses } from '../utils/SimplifiedThreadDepth';\n\n/**\n * Initialize Post component extensions for threading\n * \n * Sets up all the necessary hooks and extensions for the Post component\n * to display threading information properly.\n */\nexport function initThreadedPost() {\n  // Hook into Post component to add threading CSS classes\n  extend(Post.prototype, 'classes', function(classes) {\n    const post = this.attrs.post;\n    \n    // Skip processing if we don't have a valid post\n    if (!post) {\n      console.warn('[Threadify] No post in ThreadedPost.classes');\n      return classes;\n    }\n    \n    // Get threading CSS classes from simplified utility\n    const threadClasses = getThreadCssClasses(post);\n    console.log(`[Threadify] Adding classes to post ${post.id()}: ${threadClasses.join(', ')}`);\n    \n    threadClasses.forEach(className => {\n      classes.push(className);\n    });\n    \n    return classes;\n  });\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts useful threading metadata from a post that can be used\n * by other components or for debugging purposes.\n * \n * @param {Post} post - The post to extract metadata from\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Object} - Thread metadata object\n */\nexport function getPostThreadMetadata(post, allPosts) {\n  if (!post) return null;\n  \n  const parentId = post.attribute('parent_id');\n  const parentPost = parentId ? allPosts.find(p => p && p.id() == parentId) : null;\n  \n  // Find direct children of this post\n  const children = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  // Calculate some thread statistics\n  const descendants = getDescendantCount(post, allPosts);\n  \n  return {\n    postId: post.id(),\n    parentId: parentId,\n    hasParent: !!parentPost,\n    parentPost: parentPost,\n    directChildren: children,\n    childrenCount: children.length,\n    descendantCount: descendants,\n    isRootPost: !parentId,\n    threadClasses: getThreadCssClasses(post, allPosts)\n  };\n}\n\n/**\n * Count all descendants (children, grandchildren, etc.) of a post\n * \n * @param {Post} post - The post to count descendants for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {number} - Total number of descendants\n */\nfunction getDescendantCount(post, allPosts) {\n  const directChildren = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  let count = directChildren.length;\n  \n  // Recursively count descendants of each child\n  directChildren.forEach(child => {\n    count += getDescendantCount(child, allPosts);\n  });\n  \n  return count;\n}\n\n/**\n * Check if a post is part of a specific thread branch\n * \n * Determines if a post is either a descendant or ancestor of another post.\n * Useful for highlighting related posts or collapsing thread branches.\n * \n * @param {Post} post1 - First post\n * @param {Post} post2 - Second post  \n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if posts are in the same thread branch\n */\nexport function arePostsInSameBranch(post1, post2, allPosts) {\n  if (!post1 || !post2 || post1.id() === post2.id()) {\n    return false;\n  }\n  \n  // Check if post1 is an ancestor of post2\n  let currentPost = post2;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post1.id()) {\n      return true; // post1 is an ancestor of post2\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  // Check if post2 is an ancestor of post1\n  currentPost = post1;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post2.id()) {\n      return true; // post2 is an ancestor of post1\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  return false;\n}\n\n/**\n * Get the root post of a thread branch\n * \n * Traces back through parent relationships to find the root post\n * of the thread branch that contains the given post.\n * \n * @param {Post} post - The post to find the root for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Post|null} - The root post of the thread branch\n */\nexport function getThreadRoot(post, allPosts) {\n  if (!post) return null;\n  \n  let currentPost = post;\n  let rootPost = post;\n  \n  // Trace back through parents until we find a post with no parent\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) {\n      rootPost = currentPost;\n      break;\n    }\n    \n    const parentPost = allPosts.find(p => p && p.id() == parentId);\n    if (!parentPost) {\n      // Parent not found, current post becomes the effective root\n      rootPost = currentPost;\n      break;\n    }\n    \n    rootPost = parentPost;\n    currentPost = parentPost;\n  }\n  \n  return rootPost;\n} \n","/**\n * Simplified Thread Depth Utilities\n * \n * This replaces the complex ThreadDepth calculation logic with simple\n * utilities that use pre-computed thread depths from the threads API.\n * \n * Benefits:\n * - No expensive depth calculations on frontend\n * - No caching needed - depth is already computed\n * - More reliable since depth is calculated once on backend\n * - Simpler code with fewer edge cases\n * \n * @author Threadify Extension\n */\n\nimport { getPostThreadMetadata } from './ThreadsApi';\n\n// Maximum allowed thread depth for UI display\nconst MAX_DISPLAY_DEPTH = 10;\n\n/**\n * Get thread depth for a post\n * \n * Uses pre-computed depth from threads API metadata instead of calculating.\n * \n * @param {Post} post - The post to get depth for\n * @returns {number} - The thread depth (0 = root, 1 = reply, etc.)\n */\nexport function getThreadDepth(post) {\n  if (!post) {\n    return 0;\n  }\n  \n  // Check if post has threading metadata from threads API\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return Math.min(metadata.depth, MAX_DISPLAY_DEPTH);\n  }\n  \n  // Fallback: use old parent_id attribute if available\n  const parentId = post.attribute('parent_id');\n  if (parentId) {\n    // Simple fallback - assume depth 1 for any post with parent\n    // This is not as accurate but prevents complete failure\n    return 1;\n  }\n  \n  // No threading information available, treat as root\n  return 0;\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * @param {Post} post - The post to get CSS classes for\n * @returns {string[]} - Array of CSS class names\n */\nexport function getThreadCssClasses(post) {\n  const depth = getThreadDepth(post);\n  const classes = [];\n  \n  if (depth > 0) {\n    classes.push('threaded-post');\n    classes.push(`thread-depth-${depth}`);\n    \n    // Add general depth classes for easier styling\n    if (depth >= 3) {\n      classes.push('thread-deep');\n    }\n    if (depth >= 5) {\n      classes.push('thread-very-deep');\n    }\n  } else {\n    classes.push('thread-root');\n  }\n  \n  // Add metadata-based classes if available\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    if (metadata.isRoot) {\n      classes.push('thread-root-confirmed');\n    }\n    if (metadata.childCount > 0) {\n      classes.push('has-children');\n      classes.push(`child-count-${Math.min(metadata.childCount, 10)}`);\n    }\n    if (metadata.descendantCount > 0) {\n      classes.push('has-descendants');\n    }\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post is a root post\n */\nexport function isRootPost(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.isRoot;\n  }\n  \n  // Fallback: check if post has no parent_id\n  return !post.attribute('parent_id');\n}\n\n/**\n * Get thread root ID for a post\n * \n * @param {Post} post - The post to get root for\n * @returns {string|null} - Root post ID or null if not available\n */\nexport function getThreadRootId(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.rootPostId;\n  }\n  \n  // Fallback: if no metadata, assume the post itself is root if no parent\n  if (!post.attribute('parent_id')) {\n    return post.id();\n  }\n  \n  return null;\n}\n\n/**\n * Get child count for a post\n * \n * @param {Post} post - The post to get child count for\n * @returns {number} - Number of direct children\n */\nexport function getChildCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.childCount : 0;\n}\n\n/**\n * Get descendant count for a post\n * \n * @param {Post} post - The post to get descendant count for\n * @returns {number} - Total number of descendants (children + grandchildren + ...)\n */\nexport function getDescendantCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.descendantCount : 0;\n}\n\n/**\n * Get thread path for a post\n * \n * @param {Post} post - The post to get thread path for\n * @returns {string|null} - Thread path (e.g., \"1/5/12\") or null if not available\n */\nexport function getThreadPath(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.threadPath : null;\n} ","/**\n * Threaded Reply Composer Extensions\n * \n * Handles ReplyComposer component extensions for threading functionality.\n * This module is responsible for:\n * - Extracting parent_id from post mentions in reply content\n * - Adding parent_id to the reply data before submission\n * - Integrating with Flarum's mentions extension for seamless threading\n * \n * The threading system works by detecting post mentions in the format:\n * @\"Display Name\"#p123 where 123 is the post ID that becomes the parent_id\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport ReplyComposer from 'flarum/forum/components/ReplyComposer';\n\n/**\n * Initialize ReplyComposer component extensions for threading\n * \n * Sets up hooks to automatically detect and add parent_id relationships\n * when users reply to specific posts using the mentions system.\n */\nexport function initThreadedReplyComposer() {\n  // Hook into reply submission to add parent_id\n  extend(ReplyComposer.prototype, 'data', function(data) {\n    const parentId = extractParentIdFromContent(data.content);\n    \n    if (parentId) {\n      // Add parent_id directly to the data object\n      data.parent_id = parentId;\n      console.log('[Threadify] Reply threading to post', parentId);\n    }\n    \n    return data;\n  });\n}\n\n/**\n * Extract parent post ID from reply content\n * \n * Parses the reply content for post mentions from the mentions extension\n * and extracts the post ID to use as parent_id for threading.\n * \n * Supported mention formats:\n * - @\"Display Name\"#p123 (standard post mention)\n * - Multiple mentions (uses the first one found)\n * \n * @param {string} content - The reply content to parse\n * @returns {number|null} - The parent post ID or null if none found\n */\nexport function extractParentIdFromContent(content) {\n  if (!content || typeof content !== 'string') {\n    return null;\n  }\n  \n  // Parse the content for post mentions from the mentions extension\n  // Format: @\"Display Name\"#p123 where 123 is the post ID\n  const postMentionMatch = content.match(/@\"[^\"]*\"#p(\\d+)/);\n  \n  if (postMentionMatch && postMentionMatch[1]) {\n    const parentId = parseInt(postMentionMatch[1], 10);\n    \n    // Validate that it's a valid number\n    if (!isNaN(parentId) && parentId > 0) {\n      return parentId;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract all mentioned post IDs from content\n * \n * Gets all post mentions from the content, not just the first one.\n * Useful for analytics or advanced threading features.\n * \n * @param {string} content - The reply content to parse\n * @returns {number[]} - Array of mentioned post IDs\n */\nexport function extractAllMentionedPostIds(content) {\n  if (!content || typeof content !== 'string') {\n    return [];\n  }\n  \n  const postMentionRegex = /@\"[^\"]*\"#p(\\d+)/g;\n  const matches = [];\n  let match;\n  \n  while ((match = postMentionRegex.exec(content)) !== null) {\n    const postId = parseInt(match[1], 10);\n    if (!isNaN(postId) && postId > 0) {\n      matches.push(postId);\n    }\n  }\n  \n  return matches;\n}\n\n/**\n * Check if content contains post mentions\n * \n * @param {string} content - The content to check\n * @returns {boolean} - True if content contains post mentions\n */\nexport function hasPostMentions(content) {\n  return extractParentIdFromContent(content) !== null;\n}\n\n/**\n * Get threading context from reply content\n * \n * Extracts comprehensive threading information from reply content,\n * including the primary parent and any additional mentioned posts.\n * \n * @param {string} content - The reply content to analyze\n * @returns {Object} - Threading context object\n */\nexport function getThreadingContext(content) {\n  const primaryParentId = extractParentIdFromContent(content);\n  const allMentionedIds = extractAllMentionedPostIds(content);\n  \n  return {\n    primaryParentId: primaryParentId,\n    allMentionedPostIds: allMentionedIds,\n    hasMentions: allMentionedIds.length > 0,\n    mentionCount: allMentionedIds.length,\n    isThreadedReply: primaryParentId !== null\n  };\n}\n\n/**\n * Validate threading data before submission\n * \n * Performs validation on the threading data to ensure it's valid\n * before the reply is submitted to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Validation result with isValid boolean and any error messages\n */\nexport function validateThreadingData(data) {\n  const result = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check if parent_id is present and valid\n  if (data.parent_id !== undefined) {\n    if (typeof data.parent_id !== 'number' || data.parent_id <= 0) {\n      result.isValid = false;\n      result.errors.push('Invalid parent_id: must be a positive number');\n    }\n  }\n  \n  // Check for potential threading issues\n  if (data.content && hasPostMentions(data.content)) {\n    const context = getThreadingContext(data.content);\n    \n    if (!data.parent_id && context.isThreadedReply) {\n      result.warnings.push('Content contains post mentions but no parent_id was set');\n    }\n    \n    if (context.mentionCount > 1) {\n      result.warnings.push(`Multiple post mentions found (${context.mentionCount}), only first will be used for threading`);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Clean threading data for submission\n * \n * Ensures threading data is properly formatted and cleaned before\n * being sent to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Cleaned data object\n */\nexport function cleanThreadingData(data) {\n  const cleanedData = { ...data };\n  \n  // Ensure parent_id is a proper integer or remove it\n  if (cleanedData.parent_id !== undefined) {\n    const parentId = parseInt(cleanedData.parent_id, 10);\n    if (!isNaN(parentId) && parentId > 0) {\n      cleanedData.parent_id = parentId;\n    } else {\n      delete cleanedData.parent_id;\n    }\n  }\n  \n  return cleanedData;\n} "],"names":["module","exports","flarum","core","compat","flattenThreadTree","rootPosts","result","addPostAndChildren","post","depth","push","children","_threadChildren","sort","a","b","createdAt","getTime","forEach","child","rootPost","createThreadedPosts","posts","threadTree","tree","postMap","Map","childrenMap","postId","id","set","parentId","attribute","has","String","get","buildThreadTree","threadDepthCache","clearThreadDepthCache","clear","loadMissingParentPosts","postStream","currentPosts","currentPostIds","Set","map","p","missingParentIds","uniqueMissingIds","Array","from","length","Promise","resolve","console","log","loadPostsByIds","then","loadedParents","allPosts","concat","error","warn","postIds","idString","join","app","store","find","filter","isReordering","reorderedPostsCache","lastPostCount","originalPostsMethod","currentDiscussionId","threadedOrder","enableMinimalChildLoading","firstFrameGated","firstBuildDone","initThreadedPostStream","extend","PostStream","_this","did","this","stream","discussion","resetState","vis","call","Boolean","hasMissingParents","original","updateReorderedCache","firstKick","vdom","m","className","LoadingIndicator","cur","count","PostStreamState","isArray","ai","undefined","bi","_temp","finishWith","originalPosts","validPosts","ensureParents","fallbackLoadParents","ensureParentsLoaded","postsWithParents","discussionPostIds","loadedPostIdSet","unloadedPostIds","sampleSize","Math","min","recentUnloaded","slice","loadedSamplePosts","actualChildren","includes","loadMinimalChildren","ensureMinimalChildren","postsReady","threaded","threadedArray","createThreadedPostsArray","idx","err","e","arrayOrNull","setTimeout","redraw","threadedPosts","nullsNeeded","max","i","_step","_iterator","_createForOfIteratorHelperLoose","done","value","pid","byId","missing","getThreadedPostsCache","forceRebuildCache","isThreadingActive","getThreadingStats","hasCachedPosts","cachedPostCount","hasOriginalMethod","discussionId","getThreadingDebugInfo","info","sample","logThreadingDebug","setMinimalChildLoading","enabled","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","r","Symbol","toStringTag","getPostThreadMetadata","_threadDepth","threadPath","_threadPath","isRoot","_isRoot","childCount","_childCount","descendantCount","_descendantCount","rootPostId","_rootPostId","initializers","add","Post","classes","attrs","threadClasses","metadata","getThreadDepth","getThreadCssClasses","ReplyComposer","data","content","postMentionMatch","match","parseInt","isNaN","extractParentIdFromContent","parent_id","window","threadifyDebug","forceRebuild","ps","require"],"sourceRoot":""}