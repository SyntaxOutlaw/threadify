{"version":3,"file":"forum.js","mappings":"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","sources":["webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/bootstrap","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/compat get default export","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/define property getters","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/hasOwnProperty shorthand","webpack://@syntaxoutlaw/flarum-ext-threadify/webpack/runtime/make namespace object","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['common/extend']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/PostStream']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadsApi.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/SimplifiedThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/Post']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/external root \"flarum.core.compat['forum/components/ReplyComposer']\"","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedReplyComposer.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadTree.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/ThreadDepth.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPostStream.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/index.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/components/ThreadedPost.js","webpack://@syntaxoutlaw/flarum-ext-threadify/./src/forum/utils/SimplifiedThreadDepth.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/PostStream'];","/**\n * Threads API Utilities\n * \n * Simple API interface for loading threaded post data from the new\n * threadify_threads table. This replaces the complex dynamic threading\n * logic with efficient pre-computed thread structures.\n * \n * @author Threadify Extension\n */\n\n/**\n * Load all threads for a discussion\n * \n * Makes a single API call to get complete thread structure with all\n * posts in proper threaded order. No complex post loading or tree\n * building needed on the frontend.\n * \n * @param {number} discussionId - The discussion ID to load threads for\n * @returns {Promise<Object[]>} - Promise resolving to array of thread objects\n */\nexport function loadDiscussionThreads(discussionId) {\n  console.log(`[Threadify] Loading threads for discussion ${discussionId}`);\n  \n  // Use Flarum's request method to call our custom API endpoint\n  return app.request({\n    method: 'GET',\n    url: app.forum.attribute('apiUrl') + '/discussions/' + discussionId + '/threads'\n  }).then(response => {\n    console.log(`[Threadify] Loaded ${response.data.length} thread entries`);\n    \n    // Process included data first to populate the store\n    if (response.included) {\n      console.log(`[Threadify] Processing ${response.included.length} included items`);\n      response.included.forEach(item => {\n        console.log(`[Threadify] Including ${item.type}:${item.id}`);\n        app.store.pushObject(item);\n      });\n    }\n    \n    // Convert thread data to posts with threading metadata\n    const threadedPosts = response.data.map(threadData => {\n      // Find the post in Flarum's store\n      const postId = threadData.attributes.postId;\n      let post = app.store.getById('posts', postId);\n      \n      if (post) {\n        // Debug: Check if post has user relationship\n        console.log(`[Threadify] Post ${postId} found, user:`, post.user ? post.user() : 'NO USER');\n        \n        // Add threading metadata to the post\n        post._threadDepth = threadData.attributes.depth;\n        post._threadPath = threadData.attributes.threadPath;\n        post._isRoot = threadData.attributes.isRoot;\n        post._childCount = threadData.attributes.childCount;\n        post._descendantCount = threadData.attributes.descendantCount;\n        post._rootPostId = threadData.attributes.rootPostId;\n        post._parentPostId = threadData.attributes.parentPostId;\n        \n        console.log(`[Threadify] Post ${postId} depth: ${post._threadDepth}, path: ${post._threadPath}`);\n      } else {\n        console.warn(`[Threadify] Post ${postId} not found in store`);\n      }\n      \n      return post;\n    }).filter(post => post !== null); // Filter out any null posts\n    \n    console.log(`[Threadify] Processed ${threadedPosts.length} threaded posts`);\n    \n    return threadedPosts;\n  }).catch(error => {\n    console.error('[Threadify] Failed to load discussion threads:', error);\n    \n    // Fallback: return empty array - existing PostStream will handle this gracefully\n    return [];\n  });\n}\n\n/**\n * Check if threads API is available for a discussion\n * \n * @param {Discussion} discussion - The discussion to check\n * @returns {boolean} - True if threads API should be used\n */\nexport function shouldUseThreadsApi(discussion) {\n  // For now, always try to use the threads API\n  // In the future, this could be configurable or based on discussion settings\n  return true;\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts threading information that was added by loadDiscussionThreads\n * \n * @param {Post} post - The post to get metadata for\n * @returns {Object|null} - Thread metadata or null if not available\n */\nexport function getPostThreadMetadata(post) {\n  if (!post || typeof post._threadDepth === 'undefined') {\n    return null;\n  }\n  \n  return {\n    depth: post._threadDepth,\n    threadPath: post._threadPath,\n    isRoot: post._isRoot,\n    childCount: post._childCount,\n    descendantCount: post._descendantCount,\n    rootPostId: post._rootPostId\n  };\n}\n\n/**\n * Check if a post has threading metadata\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post has threading metadata\n */\nexport function hasThreadMetadata(post) {\n  return post && typeof post._threadDepth !== 'undefined';\n} ","/**\n * Simplified Threaded PostStream Component\n * \n * This is a complete replacement for the complex ThreadedPostStream logic.\n * Instead of dynamic tree building and complex caching, this simply calls\n * the threads API to get pre-computed thread structures.\n * \n * Benefits:\n * - Single API call instead of multiple post loading calls  \n * - No complex caching or state management\n * - No dynamic tree building on frontend\n * - Much more reliable and performant\n * - Easier to understand and maintain\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport { loadDiscussionThreads, shouldUseThreadsApi } from '../utils/ThreadsApi';\n\n// Simple state management - no complex caching needed\nlet threadsLoaded = false;\nlet threadedPosts = null;\nlet currentDiscussionId = null;\nlet lastPostCount = 0; // Track last post count to detect updates\n\n/**\n * Initialize the simplified threaded PostStream\n * \n * This replaces the complex threading logic with a simple API-based approach.\n */\nexport function initSimplifiedThreadedPostStream() {\n  \n  // Override posts method when PostStream initializes\n  extend(PostStream.prototype, 'oninit', function() {\n    console.log('[Threadify] Initializing simplified threaded PostStream');\n    \n    // Get discussion ID\n    const discussionId = this.stream.discussion.id();\n    \n    // Reset state if discussion changed\n    if (currentDiscussionId !== discussionId) {\n      console.log('[Threadify] Discussion changed, resetting thread state');\n      threadsLoaded = false;\n      threadedPosts = null;\n      currentDiscussionId = discussionId;\n    }\n    \n    // Load threads if needed\n    if (shouldUseThreadsApi(this.stream.discussion) && !threadsLoaded) {\n      console.log('[Threadify] Loading threaded posts from API');\n      loadThreadedPosts(this);\n    }\n  });\n  \n  // Handle discussion changes\n  extend(PostStream.prototype, 'oncreate', function() {\n    const discussionId = this.stream.discussion.id();\n    \n    // Reset if discussion changed\n    if (currentDiscussionId !== discussionId) {\n      console.log('[Threadify] Discussion changed in oncreate, resetting');\n      threadsLoaded = false;\n      threadedPosts = null;\n      currentDiscussionId = discussionId;\n      \n      // Load threads for new discussion\n      if (shouldUseThreadsApi(this.stream.discussion)) {\n        loadThreadedPosts(this);\n      }\n    }\n  });\n\n  // Handle post stream updates to reload threads when new posts are added\n  extend(PostStream.prototype, 'onupdate', function() {\n    // Only check for updates if we're using threads API\n    if (!shouldUseThreadsApi(this.stream.discussion)) {\n      return;\n    }\n    \n    // Get current post count from the stream\n    const currentPosts = this.stream.posts();\n    const currentPostCount = currentPosts ? currentPosts.filter(p => p).length : 0;\n    \n    // If post count changed, reload threads\n    if (currentPostCount !== lastPostCount) {\n      console.log(`[Threadify] Post count changed: ${lastPostCount} -> ${currentPostCount}, reloading threads`);\n      lastPostCount = currentPostCount;\n      \n      // Reset and reload\n      threadsLoaded = false;\n      threadedPosts = null;\n      loadThreadedPosts(this);\n    }\n  });\n\n  // Clean up when component is destroyed\n  extend(PostStream.prototype, 'onremove', function() {\n    console.log('[Threadify] PostStream being removed, cleaning up');\n    // Don't reset state here as it might be needed for other instances\n  });\n\n  // Override the posts getter to return threaded posts when available\n  extend(PostStream.prototype, 'posts', function(original) {\n    // If we have threaded posts loaded for this discussion, return them\n    if (threadsLoaded && threadedPosts && currentDiscussionId === this.stream.discussion.id()) {\n      console.log(`[Threadify] Returning cached threaded posts (${threadedPosts.length} posts)`);\n      return threadedPosts;\n    }\n    \n    // Otherwise return original posts\n    const originalPosts = original();\n    console.log(`[Threadify] Returning original posts (${originalPosts ? originalPosts.length : 0} posts)`);\n    return originalPosts;\n  });\n}\n\n/**\n * Load threaded posts from the API\n * \n * @param {PostStream} postStream - The PostStream instance\n */\nfunction loadThreadedPosts(postStream) {\n  const discussionId = postStream.stream.discussion.id();\n  \n  console.log(`[Threadify] Loading threads for discussion ${discussionId}`);\n  \n  loadDiscussionThreads(discussionId)\n    .then(posts => {\n      // Only update if we're still on the same discussion\n      if (currentDiscussionId === discussionId) {\n        threadedPosts = posts;\n        threadsLoaded = true;\n        \n        // Update post count tracking\n        lastPostCount = posts ? posts.filter(p => p).length : 0;\n        \n        console.log(`[Threadify] Successfully loaded ${threadedPosts.length} threaded posts`);\n        console.log('[Threadify] Sample post metadata:', threadedPosts[0] ? {\n          id: threadedPosts[0].id(),\n          depth: threadedPosts[0]._threadDepth,\n          hasUser: !!threadedPosts[0].user,\n          userFunction: typeof threadedPosts[0].user\n        } : 'No posts');\n        \n        m.redraw();\n      } else {\n        console.log('[Threadify] Discussion changed while loading, ignoring results');\n      }\n    })\n    .catch(error => {\n      console.error('[Threadify] Failed to load threaded posts:', error);\n      \n      // Mark as loaded anyway to prevent infinite retries\n      threadsLoaded = true;\n      \n      // Keep using original posts as fallback\n      threadedPosts = null;\n    });\n}\n\n/**\n * Get current threading state (for debugging)\n * \n * @returns {Object} - Current state information\n */\nexport function getThreadingState() {\n  return {\n    threadsLoaded,\n    hasThreadedPosts: !!threadedPosts,\n    threadedPostCount: threadedPosts ? threadedPosts.length : 0,\n    currentDiscussionId\n  };\n}\n\n/**\n * Force reload threads for current discussion\n * \n * Useful for testing or when posts are added/modified\n */\nexport function reloadThreads() {\n  console.log('[Threadify] Force reloading threads');\n  threadsLoaded = false;\n  threadedPosts = null;\n  \n  // Trigger a redraw to start the reload process\n  m.redraw();\n}\n\n/**\n * Check if threading is currently active\n * \n * @returns {boolean} - True if threading is active\n */\nexport function isThreadingActive() {\n  return threadsLoaded && !!threadedPosts;\n} ","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/Post'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/ReplyComposer'];","/**\n * Threaded Reply Composer Extensions\n * \n * Handles ReplyComposer component extensions for threading functionality.\n * This module is responsible for:\n * - Extracting parent_id from post mentions in reply content\n * - Adding parent_id to the reply data before submission\n * - Integrating with Flarum's mentions extension for seamless threading\n * \n * The threading system works by detecting post mentions in the format:\n * @\"Display Name\"#p123 where 123 is the post ID that becomes the parent_id\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport ReplyComposer from 'flarum/forum/components/ReplyComposer';\n\n/**\n * Initialize ReplyComposer component extensions for threading\n * \n * Sets up hooks to automatically detect and add parent_id relationships\n * when users reply to specific posts using the mentions system.\n */\nexport function initThreadedReplyComposer() {\n  // Hook into reply submission to add parent_id\n  extend(ReplyComposer.prototype, 'data', function(data) {\n    const parentId = extractParentIdFromContent(data.content);\n    \n    if (parentId) {\n      // Add parent_id directly to the data object\n      data.parent_id = parentId;\n      console.log('[Threadify] Reply threading to post', parentId);\n    }\n    \n    return data;\n  });\n}\n\n/**\n * Extract parent post ID from reply content\n * \n * Parses the reply content for post mentions from the mentions extension\n * and extracts the post ID to use as parent_id for threading.\n * \n * Supported mention formats:\n * - @\"Display Name\"#p123 (standard post mention)\n * - Multiple mentions (uses the first one found)\n * \n * @param {string} content - The reply content to parse\n * @returns {number|null} - The parent post ID or null if none found\n */\nexport function extractParentIdFromContent(content) {\n  if (!content || typeof content !== 'string') {\n    return null;\n  }\n  \n  // Parse the content for post mentions from the mentions extension\n  // Format: @\"Display Name\"#p123 where 123 is the post ID\n  const postMentionMatch = content.match(/@\"[^\"]*\"#p(\\d+)/);\n  \n  if (postMentionMatch && postMentionMatch[1]) {\n    const parentId = parseInt(postMentionMatch[1], 10);\n    \n    // Validate that it's a valid number\n    if (!isNaN(parentId) && parentId > 0) {\n      return parentId;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Extract all mentioned post IDs from content\n * \n * Gets all post mentions from the content, not just the first one.\n * Useful for analytics or advanced threading features.\n * \n * @param {string} content - The reply content to parse\n * @returns {number[]} - Array of mentioned post IDs\n */\nexport function extractAllMentionedPostIds(content) {\n  if (!content || typeof content !== 'string') {\n    return [];\n  }\n  \n  const postMentionRegex = /@\"[^\"]*\"#p(\\d+)/g;\n  const matches = [];\n  let match;\n  \n  while ((match = postMentionRegex.exec(content)) !== null) {\n    const postId = parseInt(match[1], 10);\n    if (!isNaN(postId) && postId > 0) {\n      matches.push(postId);\n    }\n  }\n  \n  return matches;\n}\n\n/**\n * Check if content contains post mentions\n * \n * @param {string} content - The content to check\n * @returns {boolean} - True if content contains post mentions\n */\nexport function hasPostMentions(content) {\n  return extractParentIdFromContent(content) !== null;\n}\n\n/**\n * Get threading context from reply content\n * \n * Extracts comprehensive threading information from reply content,\n * including the primary parent and any additional mentioned posts.\n * \n * @param {string} content - The reply content to analyze\n * @returns {Object} - Threading context object\n */\nexport function getThreadingContext(content) {\n  const primaryParentId = extractParentIdFromContent(content);\n  const allMentionedIds = extractAllMentionedPostIds(content);\n  \n  return {\n    primaryParentId: primaryParentId,\n    allMentionedPostIds: allMentionedIds,\n    hasMentions: allMentionedIds.length > 0,\n    mentionCount: allMentionedIds.length,\n    isThreadedReply: primaryParentId !== null\n  };\n}\n\n/**\n * Validate threading data before submission\n * \n * Performs validation on the threading data to ensure it's valid\n * before the reply is submitted to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Validation result with isValid boolean and any error messages\n */\nexport function validateThreadingData(data) {\n  const result = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check if parent_id is present and valid\n  if (data.parent_id !== undefined) {\n    if (typeof data.parent_id !== 'number' || data.parent_id <= 0) {\n      result.isValid = false;\n      result.errors.push('Invalid parent_id: must be a positive number');\n    }\n  }\n  \n  // Check for potential threading issues\n  if (data.content && hasPostMentions(data.content)) {\n    const context = getThreadingContext(data.content);\n    \n    if (!data.parent_id && context.isThreadedReply) {\n      result.warnings.push('Content contains post mentions but no parent_id was set');\n    }\n    \n    if (context.mentionCount > 1) {\n      result.warnings.push(`Multiple post mentions found (${context.mentionCount}), only first will be used for threading`);\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Clean threading data for submission\n * \n * Ensures threading data is properly formatted and cleaned before\n * being sent to the server.\n * \n * @param {Object} data - The reply data object\n * @returns {Object} - Cleaned data object\n */\nexport function cleanThreadingData(data) {\n  const cleanedData = { ...data };\n  \n  // Ensure parent_id is a proper integer or remove it\n  if (cleanedData.parent_id !== undefined) {\n    const parentId = parseInt(cleanedData.parent_id, 10);\n    if (!isNaN(parentId) && parentId > 0) {\n      cleanedData.parent_id = parentId;\n    } else {\n      delete cleanedData.parent_id;\n    }\n  }\n  \n  return cleanedData;\n} ","/**\n * Thread Tree Utilities\n * \n * Handles building and flattening thread tree structures from Flarum posts.\n * This module is responsible for:\n * - Building hierarchical thread structures from flat post arrays\n * - Flattening thread trees back to linear arrays in threaded order\n * - Maintaining parent-child relationships between posts\n * \n * @author Threadify Extension\n */\n\n/**\n * Build a threaded tree structure from posts\n * \n * Takes a flat array of posts and organizes them into a hierarchical tree\n * structure based on their parent_id attributes. Posts without a parent_id\n * become root posts, while posts with parent_id become children of their\n * respective parents.\n * \n * @param {Post[]} posts - All posts in the discussion\n * @returns {Post[]} - Array of root posts with _threadChildren attached\n */\nexport function buildThreadTree(posts) {\n  const tree = [];\n  const postMap = new Map();\n  const childrenMap = new Map();\n  \n  // First pass: create post map and initialize children arrays\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    postMap.set(postId, post);\n    childrenMap.set(postId, []);\n  });\n  \n  // Second pass: organize posts by parent-child relationships\n  posts.forEach(post => {\n    if (!post) return;\n    \n    const postId = post.id();\n    const parentId = post.attribute('parent_id');\n    \n    if (parentId && postMap.has(String(parentId))) {\n      // This post has a parent, add it to parent's children\n      childrenMap.get(String(parentId)).push(post);\n    } else {\n      // This is a root post (no parent or parent not found)\n      tree.push(post);\n    }\n  });\n  \n  // Third pass: attach children to posts for easy access\n  posts.forEach(post => {\n    if (!post) return;\n    post._threadChildren = childrenMap.get(post.id()) || [];\n  });\n  \n  return tree;\n}\n\n/**\n * Flatten thread tree back to linear array in threaded order\n * \n * Takes a hierarchical tree of posts and flattens it back to a linear array\n * while maintaining the threaded order (parent followed by all its children\n * recursively). This preserves the threading visual structure when posts\n * are rendered linearly.\n * \n * @param {Post[]} rootPosts - Root posts with their children attached via _threadChildren\n * @returns {Post[]} - Flattened array in threaded order\n */\nexport function flattenThreadTree(rootPosts) {\n  const result = [];\n  \n  /**\n   * Recursively add a post and all its children to the result array\n   * @param {Post} post - The post to add\n   * @param {number} depth - Current nesting depth (for potential future use)\n   */\n  function addPostAndChildren(post, depth = 0) {\n    if (!post) return;\n    \n    result.push(post);\n    \n    // Get children and sort them chronologically within each thread level\n    const children = post._threadChildren || [];\n    children.sort((a, b) => {\n      const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n      const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n      return timeA - timeB;\n    });\n    \n    // Recursively add all children\n    children.forEach(child => {\n      addPostAndChildren(child, depth + 1);\n    });\n  }\n  \n  // Sort root posts chronologically to maintain discussion flow\n  rootPosts.sort((a, b) => {\n    const timeA = a.createdAt ? a.createdAt().getTime() : 0;\n    const timeB = b.createdAt ? b.createdAt().getTime() : 0;\n    return timeA - timeB;\n  });\n  \n  // Add each root post and its entire thread branch\n  rootPosts.forEach(rootPost => {\n    addPostAndChildren(rootPost);\n  });\n  \n  return result;\n}\n\n/**\n * Create a threaded post array from flat posts\n * \n * Convenience function that combines buildThreadTree and flattenThreadTree\n * to convert a flat array of posts directly into threaded order.\n * \n * @param {Post[]} posts - Flat array of posts\n * @returns {Post[]} - Posts reordered in threaded structure\n */\nexport function createThreadedPosts(posts) {\n  const threadTree = buildThreadTree(posts);\n  return flattenThreadTree(threadTree);\n} ","/**\n * Thread Depth Calculator\n * \n * Handles calculating and caching thread depth for posts.\n * Thread depth determines how many levels deep a post is in a thread\n * (0 = root post, 1 = direct reply, 2 = reply to reply, etc.)\n * \n * Uses caching to avoid expensive recalculations and includes cycle detection\n * to prevent infinite loops in case of malformed parent relationships.\n * \n * @author Threadify Extension\n */\n\n// Cache for thread depth calculations to avoid recalculating\nconst threadDepthCache = new Map();\n\n// Maximum allowed thread depth to prevent excessive UI indentation\nconst MAX_THREAD_DEPTH = 10;\n\n/**\n * Calculate the thread depth of a post\n * \n * Determines how many levels deep a post is in the thread hierarchy.\n * Uses caching for performance and includes cycle detection for safety.\n * \n * @param {Post} post - The post to calculate depth for\n * @param {Post[]} allPosts - All posts in the discussion (for parent lookup)\n * @returns {number} - The depth (0 = root, 1 = direct reply, etc.)\n */\nexport function calculateThreadDepth(post, allPosts) {\n  const postId = post.id();\n  \n  // Check cache first for performance\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent_id, this is a root post (depth 0)\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Find the parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    // Parent not found, treat as root\n    threadDepthCache.set(postId, 0);\n    return 0;\n  }\n  \n  // Cycle detection: if we're calculating depth for a post that's already\n  // in our calculation chain, we have a cycle\n  const visited = new Set();\n  const depth = calculateDepthRecursive(post, allPosts, visited);\n  \n  // Cache and return the calculated depth\n  threadDepthCache.set(postId, depth);\n  return depth;\n}\n\n/**\n * Recursive helper for depth calculation with cycle detection\n * @param {Post} post - Current post\n * @param {Post[]} allPosts - All posts for parent lookup\n * @param {Set} visited - Set of visited post IDs to detect cycles\n * @returns {number} - Calculated depth\n */\nfunction calculateDepthRecursive(post, allPosts, visited) {\n  const postId = post.id();\n  \n  // Cycle detection\n  if (visited.has(postId)) {\n    console.warn(`[Threadify] Cycle detected for post ${postId}`);\n    return 0; // Treat cyclic posts as root to break the cycle\n  }\n  \n  // Check cache\n  if (threadDepthCache.has(postId)) {\n    return threadDepthCache.get(postId);\n  }\n  \n  // If no parent, this is root level\n  const parentId = post.attribute('parent_id');\n  if (!parentId) {\n    return 0;\n  }\n  \n  // Find parent post\n  const parentPost = allPosts.find(p => p && p.id() == parentId);\n  if (!parentPost) {\n    return 0; // Parent not found, treat as root\n  }\n  \n  // Add current post to visited set\n  visited.add(postId);\n  \n  // Recursively calculate parent's depth\n  const parentDepth = calculateDepthRecursive(parentPost, allPosts, visited);\n  const depth = parentDepth + 1;\n  \n  // Remove from visited set (backtrack)\n  visited.delete(postId);\n  \n  // Apply maximum depth limit to prevent excessive UI indentation\n  return Math.min(depth, MAX_THREAD_DEPTH);\n}\n\n/**\n * Clear the thread depth cache\n * \n * Should be called when posts are updated, removed, or when switching discussions\n * to ensure fresh calculations.\n */\nexport function clearThreadDepthCache() {\n  threadDepthCache.clear();\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * Generates appropriate CSS classes for styling threaded posts.\n * \n * @param {Post} post - The post to generate classes for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {string[]} - Array of CSS classes\n */\nexport function getThreadCssClasses(post, allPosts) {\n  const threadDepth = calculateThreadDepth(post, allPosts);\n  const classes = [];\n  \n  if (threadDepth > 0) {\n    classes.push('Post--threaded');\n    classes.push(`Post--thread-depth-${threadDepth}`);\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * @param {Post} post - The post to check\n * @returns {boolean} - True if the post is a root post\n */\nexport function isRootPost(post) {\n  return !post.attribute('parent_id');\n}\n\n/**\n * Check if a post is a direct reply (depth 1)\n * @param {Post} post - The post to check\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if the post is a direct reply\n */\nexport function isDirectReply(post, allPosts) {\n  return calculateThreadDepth(post, allPosts) === 1;\n} ","/**\n * Threaded PostStream Component Extensions\n * \n * Handles PostStream component extensions for threading functionality.\n * This is the core module that manages:\n * - Overriding PostStream's posts() method to return threaded posts\n * - Caching threaded post arrangements for performance\n * - Detecting when posts change and rebuilding thread cache\n * - Integrating with PostLoader for complete thread context\n * - Managing the complex lifecycle of post stream updates\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport PostStream from 'flarum/forum/components/PostStream';\nimport { createThreadedPosts } from '../utils/ThreadTree';\nimport { clearThreadDepthCache } from '../utils/ThreadDepth';\nimport { loadMinimalChildren } from '../utils/PostLoader';\n\n// Global state for the PostStream threading system\nlet isReordering = false; // Prevent infinite loops during reordering\nlet reorderedPostsCache = null; // Cache for threaded posts arrangement\nlet lastPostCount = 0; // Track post count to detect actual changes\nlet originalPostsMethod = null;\n\n// Configuration flag for optional minimal child loading\nlet enableMinimalChildLoading = false;\n\n/**\n * Initialize PostStream component extensions for threading\n * \n * Sets up all the necessary hooks and overrides to make PostStream\n * display posts in threaded order while maintaining compatibility\n * with Flarum's existing post loading and updating mechanisms.\n */\nexport function initThreadedPostStream() {\n  // Override posts method immediately when PostStream initializes (before any rendering)\n  extend(PostStream.prototype, 'oninit', function() {\n    \n    // Store reference to original posts method\n    originalPostsMethod = this.stream.posts;\n    \n    // Override posts() method immediately, before any rendering\n    this.stream.posts = () => {\n      // If we have threaded cache, return it\n      if (reorderedPostsCache) {\n        console.log(`[Threadify] Returning threaded posts (${reorderedPostsCache.filter(p => p).length} posts)`);\n        return reorderedPostsCache;\n      }\n      \n      // If no cache, return original posts and trigger rebuild\n      const originalPosts = originalPostsMethod.call(this.stream);\n      console.log(`[Threadify] No cache, returning original posts (${originalPosts ? originalPosts.filter(p => p).length : 0} posts)`);\n      \n      // Trigger cache rebuild if we have posts and not currently building\n      if (originalPosts && originalPosts.filter(p => p).length > 0 && !isReordering) {\n        console.log(`[Threadify] Triggering cache rebuild`);\n        updateReorderedCache(this);\n      }\n      \n      return originalPosts;\n    };\n    \n    // Initialize post count for tracking changes using original method\n    const currentPosts = originalPostsMethod.call(this.stream);\n    lastPostCount = currentPosts ? currentPosts.filter(p => p).length : 0;\n    console.log(`[Threadify] Initial post count: ${lastPostCount}`);\n    \n    // Immediately build threaded cache if we have posts\n    if (currentPosts && currentPosts.length > 0) {\n      updateReorderedCache(this);\n    }\n  });\n  \n  // Hook into PostStream.view() to ensure cache is ready during rendering\n  extend(PostStream.prototype, 'view', function(result) {\n    // Update our reordered cache if needed\n    if (!reorderedPostsCache && originalPostsMethod) {\n      updateReorderedCache(this);\n    }\n    \n    return result;\n  });\n  \n  // Clear caches when component is created (discussion change, etc.)\n  extend(PostStream.prototype, 'oncreate', function() {\n    clearThreadDepthCache();\n    // Note: Don't clear reorderedPostsCache here as it was built in oninit\n  });\n  \n  // Rebuild cache immediately when posts are updated\n  extend(PostStream.prototype, 'onupdate', function() {\n    handlePostStreamUpdate(this);\n  });\n}\n\n/**\n * Handle PostStream updates and rebuild cache when needed\n * \n * @param {PostStream} postStream - The PostStream instance\n */\nfunction handlePostStreamUpdate(postStream) {\n  // Don't interfere if we're already reordering\n  if (isReordering) {\n    return;\n  }\n  \n  // Check if post count actually changed using original posts method\n  if (!originalPostsMethod) return; // No original method stored yet\n  \n  const currentPosts = originalPostsMethod.call(postStream.stream);\n  const currentPostCount = currentPosts ? currentPosts.filter(p => p).length : 0;\n  \n  // Only rebuild if post count changed (indicating new/removed posts)\n  if (currentPostCount !== lastPostCount) {\n    console.log(`[Threadify] Post count changed: ${lastPostCount} -> ${currentPostCount}, rebuilding cache`);\n    \n    // Update tracked count\n    lastPostCount = currentPostCount;\n    \n    // Clear old cache completely and rebuild with simple threading\n    reorderedPostsCache = null;\n    clearThreadDepthCache();\n    \n    // Simple immediate rebuild without context loading\n    updateReorderedCache(postStream);\n  }\n}\n\n/**\n * Update the reordered posts cache with simple threaded arrangement\n * \n * Simplified approach: just do basic threading with current posts,\n * with optional minimal child loading if enabled.\n * \n * @param {PostStream} postStream - The PostStream instance\n */\nfunction updateReorderedCache(postStream) {\n  if (isReordering) {\n    return;\n  }\n  \n  isReordering = true;\n  \n  try {\n    // Get the ORIGINAL posts from the stream using the stored original method\n    if (!originalPostsMethod) {\n      reorderedPostsCache = null;\n      return;\n    }\n    \n    const originalPosts = originalPostsMethod.call(postStream.stream);\n    \n    if (!originalPosts || originalPosts.length === 0) {\n      reorderedPostsCache = null;\n      return;\n    }\n    \n    // Filter out null/undefined posts\n    const validPosts = originalPosts.filter(post => post);\n    \n    if (validPosts.length === 0) {\n      reorderedPostsCache = null;\n      return;\n    }\n    \n    // Check if minimal child loading is enabled\n    if (enableMinimalChildLoading) {\n      // Load minimal children and then apply threading\n      loadMinimalChildren(postStream, validPosts)\n        .then((postsWithChildren) => {\n          if (!isReordering) return; // Skip if another rebuild started\n          \n          const threadedPosts = createThreadedPosts(postsWithChildren);\n          const threadedArray = createThreadedPostsArray(originalPosts, threadedPosts);\n          \n          reorderedPostsCache = threadedArray;\n          console.log(`[Threadify] Applied threading with minimal children (${threadedPosts.length} posts)`);\n          \n          setTimeout(() => {\n            m.redraw();\n          }, 10);\n        })\n        .catch(error => {\n          console.warn('[Threadify] Minimal child loading failed, using basic threading:', error);\n          // Fallback to basic threading\n          const threadedPosts = createThreadedPosts(validPosts);\n          const threadedArray = createThreadedPostsArray(originalPosts, threadedPosts);\n          reorderedPostsCache = threadedArray;\n        })\n        .finally(() => {\n          isReordering = false;\n        });\n    } else {\n      // Simple threading with current posts only - no context loading\n      const threadedPosts = createThreadedPosts(validPosts);\n      const threadedArray = createThreadedPostsArray(originalPosts, threadedPosts);\n      \n      // Update cache\n      reorderedPostsCache = threadedArray;\n      \n      console.log(`[Threadify] Applied simple threading (${threadedPosts.length} posts)`);\n      \n      // Force immediate redraw\n      setTimeout(() => {\n        m.redraw();\n      }, 10);\n      \n      isReordering = false;\n    }\n    \n  } catch (error) {\n    console.error('[Threadify] Cache update failed:', error);\n    isReordering = false;\n  }\n}\n\n/**\n * Create threaded posts array that preserves all loaded posts in threaded order\n * \n * Instead of trying to maintain original positions, this creates an array\n * where posts appear in proper threaded order, followed by any null entries\n * for unloaded posts (to maintain pagination).\n * \n * @param {(Post|null)[]} originalPosts - Original posts array from PostStream\n * @param {Post[]} threadedPosts - Posts in threaded order\n * @returns {(Post|null)[]} - Array with all posts in threaded order\n */\nfunction createThreadedPostsArray(originalPosts, threadedPosts) {\n  if (!threadedPosts || threadedPosts.length === 0) {\n    return originalPosts;\n  }\n  \n  // Start with all threaded posts in their correct order\n  const result = [...threadedPosts];\n  \n  // Count how many non-null posts were in the original array\n  const originalNonNullCount = originalPosts.filter(p => p !== null).length;\n  \n  // If we have more threaded posts than original non-null posts,\n  // it means we loaded additional parent/child posts - that's great!\n  // If we have fewer, we need to pad with nulls to maintain pagination\n  const nullsNeeded = Math.max(0, originalPosts.length - threadedPosts.length);\n  \n  // Add null entries at the end to maintain original array length for pagination\n  for (let i = 0; i < nullsNeeded; i++) {\n    result.push(null);\n  }\n  \n  return result;\n}\n\n/**\n * Get the current threaded posts cache\n * \n * @returns {(Post|null)[]|null} - The cached threaded posts or null if not available\n */\nexport function getThreadedPostsCache() {\n  return reorderedPostsCache;\n}\n\n/**\n * Force rebuild of the threaded posts cache\n * \n * Useful for external components that need to trigger a cache rebuild,\n * such as after manual post operations.\n * \n * @param {PostStream} postStream - The PostStream instance\n */\nexport function forceRebuildCache(postStream) {\n  console.log('[Threadify] Force rebuilding cache');\n  \n  // Clear existing cache and depth cache\n  reorderedPostsCache = null;\n  clearThreadDepthCache();\n  \n  // Use the simplified rebuild approach\n  updateReorderedCache(postStream);\n}\n\n/**\n * Check if threading is currently active\n * \n * @returns {boolean} - True if threading is active and cache is available\n */\nexport function isThreadingActive() {\n  return !!(reorderedPostsCache && originalPostsMethod);\n}\n\n/**\n * Get threading statistics for debugging\n * \n * @returns {Object} - Object containing threading statistics\n */\nexport function getThreadingStats() {\n  return {\n    hasCachedPosts: !!reorderedPostsCache,\n    cachedPostCount: reorderedPostsCache ? reorderedPostsCache.filter(p => p).length : 0,\n    isReordering: isReordering,\n    lastPostCount: lastPostCount,\n    hasOriginalMethod: !!originalPostsMethod\n  };\n} \n\n/**\n * Get debug information about the current threading state\n * \n * @returns {Object} - Debug information object\n */\nexport function getThreadingDebugInfo() {\n  return {\n    isReordering: isReordering,\n    hasCachedPosts: !!reorderedPostsCache,\n    cachedPostCount: reorderedPostsCache ? reorderedPostsCache.filter(p => p).length : 0,\n    lastPostCount: lastPostCount,\n    hasOriginalMethod: !!originalPostsMethod\n  };\n}\n\n/**\n * Log detailed threading debug information\n */\nexport function logThreadingDebug() {\n  const info = getThreadingDebugInfo();\n  console.log('[Threadify] Debug Info:', info);\n  \n  if (reorderedPostsCache) {\n    const posts = reorderedPostsCache.filter(p => p);\n    console.log('[Threadify] Cache contains posts:', posts.map(p => `#${p.id()} (parent: ${p.attribute('parent_id') || 'none'})`));\n  }\n} \n\n/**\n * Enable or disable minimal child loading\n * \n * @param {boolean} enabled - Whether to enable minimal child loading\n */\nexport function setMinimalChildLoading(enabled) {\n  enableMinimalChildLoading = enabled;\n  console.log(`[Threadify] Minimal child loading ${enabled ? 'enabled' : 'disabled'}`);\n} ","/**\n * Threadify Extension - Main Entry Point\n * \n * This is the main initialization file for the Threadify extension.\n * It imports and initializes all the modular components that provide\n * threading functionality to Flarum discussions.\n * \n * The extension works by:\n * 1. Intercepting PostStream to reorder posts in threaded structure\n * 2. Adding threading CSS classes to posts for visual indentation\n * 3. Extracting parent_id from post mentions in replies\n * 4. Loading missing thread context (parents/children) as needed\n * \n * Architecture:\n * - utils/: Core threading utilities (tree building, depth calculation, post loading)\n * - components/: Flarum component extensions (PostStream, Post, ReplyComposer)\n * \n * @author Threadify Extension\n * @version 1.0.0\n */\n\n// Import utility modules\nimport { initSimplifiedThreadedPostStream, getThreadingState, reloadThreads, isThreadingActive } from './components/SimplifiedThreadedPostStream';\nimport { initThreadedPost } from './components/ThreadedPost';\nimport { initThreadedReplyComposer } from './components/ThreadedReplyComposer';\n\n/**\n * Initialize the Threadify extension\n * \n * This is the main entry point that sets up all threading functionality.\n * Called automatically by Flarum when the extension is loaded.\n */\napp.initializers.add('syntaxoutlaw-threadify', () => {\n  try {\n    // Initialize all threading components with simplified API-based approach\n    initSimplifiedThreadedPostStream();  // Simplified post threading via API\n    initThreadedPost();                  // Post CSS classes and visual elements  \n    initThreadedReplyComposer();         // Parent ID extraction from mentions\n    \n    console.log('[Threadify] Simplified extension loaded');\n    \n    // Add global debugging utilities for troubleshooting\n    window.threadifyDebug = {\n      getState: getThreadingState,\n      reload: reloadThreads,\n      isActive: isThreadingActive,\n      help: () => {\n        console.log(`\n[Threadify] Simplified Debug Commands:\n- threadifyDebug.getState() - Get current threading state\n- threadifyDebug.reload() - Force reload threads for current discussion\n- threadifyDebug.isActive() - Check if threading is currently active\n- threadifyDebug.help() - Show this help\n\nNew System: Uses pre-computed threads from backend API\n- Single API call instead of complex frontend logic\n- Pre-computed thread paths and depths\n- Much more reliable and performant\n        `);\n      }\n    };\n    \n  } catch (error) {\n    console.error('[Threadify] Failed to initialize:', error);\n  }\n});\n\n/**\n * Export utility functions for external access (if needed)\n * \n * These exports allow other extensions or debugging tools to interact\n * with Threadify's internal functionality.\n */\n\n// Re-export key utility functions for external use\nexport { createThreadedPosts } from './utils/ThreadTree';\nexport { calculateThreadDepth, clearThreadDepthCache } from './utils/ThreadDepth';\nexport { extractParentIdFromContent } from './components/ThreadedReplyComposer';\nexport { getThreadedPostsCache, isThreadingActive } from './components/ThreadedPostStream';\n\n/**\n * Get extension version and status information\n * \n * Useful for debugging and admin panels.\n * \n * @returns {Object} - Extension status information\n */\nexport function getThreadifyStatus() {\n  return {\n    version: '1.0.0',\n    name: 'Threadify',\n    author: 'syntaxoutlaw',\n    isActive: true,\n    components: {\n      postStream: 'loaded',\n      post: 'loaded', \n      replyComposer: 'loaded'\n    },\n    features: [\n      'Post threading via mentions',\n      'Automatic parent/child post loading',\n      'Visual thread depth indication',\n      'Thread tree caching for performance'\n    ]\n  };\n}\n","/**\n * Threaded Post Component Extensions\n * \n * Handles Post component extensions for threading functionality.\n * This module is responsible for:\n * - Adding threading CSS classes to posts based on their depth\n * - Managing post-specific threading visual elements\n * - Integrating with the ThreadDepth utility for depth calculations\n * \n * @author Threadify Extension\n */\n\nimport { extend } from 'flarum/common/extend';\nimport Post from 'flarum/forum/components/Post';\nimport { getThreadCssClasses } from '../utils/SimplifiedThreadDepth';\n\n/**\n * Initialize Post component extensions for threading\n * \n * Sets up all the necessary hooks and extensions for the Post component\n * to display threading information properly.\n */\nexport function initThreadedPost() {\n  // Hook into Post component to add threading CSS classes\n  extend(Post.prototype, 'classes', function(classes) {\n    const post = this.attrs.post;\n    \n    // Skip processing if we don't have a valid post\n    if (!post) {\n      console.warn('[Threadify] No post in ThreadedPost.classes');\n      return classes;\n    }\n    \n    // Get threading CSS classes from simplified utility\n    const threadClasses = getThreadCssClasses(post);\n    console.log(`[Threadify] Adding classes to post ${post.id()}: ${threadClasses.join(', ')}`);\n    \n    threadClasses.forEach(className => {\n      classes.push(className);\n    });\n    \n    return classes;\n  });\n}\n\n/**\n * Get thread metadata for a post\n * \n * Extracts useful threading metadata from a post that can be used\n * by other components or for debugging purposes.\n * \n * @param {Post} post - The post to extract metadata from\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Object} - Thread metadata object\n */\nexport function getPostThreadMetadata(post, allPosts) {\n  if (!post) return null;\n  \n  const parentId = post.attribute('parent_id');\n  const parentPost = parentId ? allPosts.find(p => p && p.id() == parentId) : null;\n  \n  // Find direct children of this post\n  const children = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  // Calculate some thread statistics\n  const descendants = getDescendantCount(post, allPosts);\n  \n  return {\n    postId: post.id(),\n    parentId: parentId,\n    hasParent: !!parentPost,\n    parentPost: parentPost,\n    directChildren: children,\n    childrenCount: children.length,\n    descendantCount: descendants,\n    isRootPost: !parentId,\n    threadClasses: getThreadCssClasses(post, allPosts)\n  };\n}\n\n/**\n * Count all descendants (children, grandchildren, etc.) of a post\n * \n * @param {Post} post - The post to count descendants for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {number} - Total number of descendants\n */\nfunction getDescendantCount(post, allPosts) {\n  const directChildren = allPosts.filter(p => \n    p && p.attribute('parent_id') == post.id()\n  );\n  \n  let count = directChildren.length;\n  \n  // Recursively count descendants of each child\n  directChildren.forEach(child => {\n    count += getDescendantCount(child, allPosts);\n  });\n  \n  return count;\n}\n\n/**\n * Check if a post is part of a specific thread branch\n * \n * Determines if a post is either a descendant or ancestor of another post.\n * Useful for highlighting related posts or collapsing thread branches.\n * \n * @param {Post} post1 - First post\n * @param {Post} post2 - Second post  \n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {boolean} - True if posts are in the same thread branch\n */\nexport function arePostsInSameBranch(post1, post2, allPosts) {\n  if (!post1 || !post2 || post1.id() === post2.id()) {\n    return false;\n  }\n  \n  // Check if post1 is an ancestor of post2\n  let currentPost = post2;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post1.id()) {\n      return true; // post1 is an ancestor of post2\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  // Check if post2 is an ancestor of post1\n  currentPost = post1;\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) break;\n    \n    if (parentId == post2.id()) {\n      return true; // post2 is an ancestor of post1\n    }\n    \n    currentPost = allPosts.find(p => p && p.id() == parentId);\n  }\n  \n  return false;\n}\n\n/**\n * Get the root post of a thread branch\n * \n * Traces back through parent relationships to find the root post\n * of the thread branch that contains the given post.\n * \n * @param {Post} post - The post to find the root for\n * @param {Post[]} allPosts - All posts in the discussion\n * @returns {Post|null} - The root post of the thread branch\n */\nexport function getThreadRoot(post, allPosts) {\n  if (!post) return null;\n  \n  let currentPost = post;\n  let rootPost = post;\n  \n  // Trace back through parents until we find a post with no parent\n  while (currentPost) {\n    const parentId = currentPost.attribute('parent_id');\n    if (!parentId) {\n      rootPost = currentPost;\n      break;\n    }\n    \n    const parentPost = allPosts.find(p => p && p.id() == parentId);\n    if (!parentPost) {\n      // Parent not found, current post becomes the effective root\n      rootPost = currentPost;\n      break;\n    }\n    \n    rootPost = parentPost;\n    currentPost = parentPost;\n  }\n  \n  return rootPost;\n} ","/**\n * Simplified Thread Depth Utilities\n * \n * This replaces the complex ThreadDepth calculation logic with simple\n * utilities that use pre-computed thread depths from the threads API.\n * \n * Benefits:\n * - No expensive depth calculations on frontend\n * - No caching needed - depth is already computed\n * - More reliable since depth is calculated once on backend\n * - Simpler code with fewer edge cases\n * \n * @author Threadify Extension\n */\n\nimport { getPostThreadMetadata } from './ThreadsApi';\n\n// Maximum allowed thread depth for UI display\nconst MAX_DISPLAY_DEPTH = 10;\n\n/**\n * Get thread depth for a post\n * \n * Uses pre-computed depth from threads API metadata instead of calculating.\n * \n * @param {Post} post - The post to get depth for\n * @returns {number} - The thread depth (0 = root, 1 = reply, etc.)\n */\nexport function getThreadDepth(post) {\n  if (!post) {\n    return 0;\n  }\n  \n  // Check if post has threading metadata from threads API\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return Math.min(metadata.depth, MAX_DISPLAY_DEPTH);\n  }\n  \n  // Fallback: use old parent_id attribute if available\n  const parentId = post.attribute('parent_id');\n  if (parentId) {\n    // Simple fallback - assume depth 1 for any post with parent\n    // This is not as accurate but prevents complete failure\n    return 1;\n  }\n  \n  // No threading information available, treat as root\n  return 0;\n}\n\n/**\n * Get CSS classes for a post based on its thread depth\n * \n * @param {Post} post - The post to get CSS classes for\n * @returns {string[]} - Array of CSS class names\n */\nexport function getThreadCssClasses(post) {\n  const depth = getThreadDepth(post);\n  const classes = [];\n  \n  if (depth > 0) {\n    classes.push('threaded-post');\n    classes.push(`thread-depth-${depth}`);\n    \n    // Add general depth classes for easier styling\n    if (depth >= 3) {\n      classes.push('thread-deep');\n    }\n    if (depth >= 5) {\n      classes.push('thread-very-deep');\n    }\n  } else {\n    classes.push('thread-root');\n  }\n  \n  // Add metadata-based classes if available\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    if (metadata.isRoot) {\n      classes.push('thread-root-confirmed');\n    }\n    if (metadata.childCount > 0) {\n      classes.push('has-children');\n      classes.push(`child-count-${Math.min(metadata.childCount, 10)}`);\n    }\n    if (metadata.descendantCount > 0) {\n      classes.push('has-descendants');\n    }\n  }\n  \n  return classes;\n}\n\n/**\n * Check if a post is a root post (no parent)\n * \n * @param {Post} post - The post to check\n * @returns {boolean} - True if post is a root post\n */\nexport function isRootPost(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.isRoot;\n  }\n  \n  // Fallback: check if post has no parent_id\n  return !post.attribute('parent_id');\n}\n\n/**\n * Get thread root ID for a post\n * \n * @param {Post} post - The post to get root for\n * @returns {string|null} - Root post ID or null if not available\n */\nexport function getThreadRootId(post) {\n  const metadata = getPostThreadMetadata(post);\n  if (metadata) {\n    return metadata.rootPostId;\n  }\n  \n  // Fallback: if no metadata, assume the post itself is root if no parent\n  if (!post.attribute('parent_id')) {\n    return post.id();\n  }\n  \n  return null;\n}\n\n/**\n * Get child count for a post\n * \n * @param {Post} post - The post to get child count for\n * @returns {number} - Number of direct children\n */\nexport function getChildCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.childCount : 0;\n}\n\n/**\n * Get descendant count for a post\n * \n * @param {Post} post - The post to get descendant count for\n * @returns {number} - Total number of descendants (children + grandchildren + ...)\n */\nexport function getDescendantCount(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.descendantCount : 0;\n}\n\n/**\n * Get thread path for a post\n * \n * @param {Post} post - The post to get thread path for\n * @returns {string|null} - Thread path (e.g., \"1/5/12\") or null if not available\n */\nexport function getThreadPath(post) {\n  const metadata = getPostThreadMetadata(post);\n  return metadata ? metadata.threadPath : null;\n} "],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","flarum","core","compat","getPostThreadMetadata","post","_threadDepth","depth","threadPath","_threadPath","isRoot","_isRoot","childCount","_childCount","descendantCount","_descendantCount","rootPostId","_rootPostId","threadsLoaded","threadedPosts","currentDiscussionId","lastPostCount","loadThreadedPosts","postStream","discussionId","stream","discussion","id","console","log","app","request","method","url","forum","attribute","then","response","data","length","included","forEach","item","type","store","pushObject","map","threadData","postId","attributes","getById","user","_parentPostId","parentPostId","warn","filter","error","loadDiscussionThreads","posts","p","hasUser","userFunction","m","redraw","getThreadingState","hasThreadedPosts","threadedPostCount","reloadThreads","isThreadingActive","extractParentIdFromContent","content","postMentionMatch","match","parentId","parseInt","isNaN","flattenThreadTree","rootPosts","result","addPostAndChildren","push","children","_threadChildren","sort","b","createdAt","getTime","child","rootPost","createThreadedPosts","threadTree","tree","postMap","Map","childrenMap","set","has","String","buildThreadTree","threadDepthCache","MAX_THREAD_DEPTH","calculateThreadDepth","allPosts","find","calculateDepthRecursive","Set","visited","parentPost","add","Math","min","clearThreadDepthCache","clear","reorderedPostsCache","originalPostsMethod","getThreadedPostsCache","getThreadifyStatus","version","name","author","isActive","components","replyComposer","features","initializers","extend","PostStream","this","currentPosts","currentPostCount","original","originalPosts","Post","classes","attrs","threadClasses","metadata","getThreadDepth","getThreadCssClasses","join","className","ReplyComposer","parent_id","window","threadifyDebug","getState","reload","help"],"sourceRoot":""}